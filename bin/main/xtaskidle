#!/usr/bin/env python

""" Stops Current TaskWarrior Task if Machine Idles for Too Long
and Restarts the Task when Activity Resumes """

import argparse
import datetime as dt
import os
import pickle
import time
import signal
import subprocess as sp
import sys

import gutils

log = gutils.logging.getEasyLogger(__name__)

NAME = os.path.basename(__file__)
PIDFILE = "{}/pid".format(gutils.xdg.getdir('runtime'))
ARGSFILE = "{}/args".format(gutils.xdg.getdir('data'))
MILLISECONDS_IN_MINUTE = 60000
DEVNULL = open(os.devnull, 'w')


def main():
    log.info('Starting {}.'.format(NAME))

    while True:
        idletime = xprintidle()
        if idletime >= args.idletime * MILLISECONDS_IN_MINUTE:
            try:
                log.debug('System has been idle for {} milliseconds.'.format(idletime))
                log.info('Stopping current task...')
                check_call('task', 'start.any:', 'stop')
            except sp.CalledProcessError as e:
                raise RuntimeError('Failed to stop task. No task is currently started.')
            else:
                check_call('timew', 'shorten', '@1', '{}mins'.format(args.idletime))
        else:
            time.sleep(args.delay * 60)
            continue

        dt_timeout = dt.datetime.now() + dt.timedelta(minutes=(args.waittime - args.idletime))
        while True:
            time.sleep(1)
            idletime = xprintidle()
            if idletime <= args.idletime * MILLISECONDS_IN_MINUTE:
                log.info('Restarting last task...')
                check_call('last_task')
                check_call('notify-send', NAME, 'The last active TaskWarrior task has been restarted.')
                break
            elif dt_timeout <= dt.datetime.now():
                log.debug('Time is now past: {}'.format(dt_timeout))
                log.info('Timed out after {} minutes of idle activity. Terminating {}.'.format(args.waittime, NAME))
                sys.exit(0)


def create_pidfile():
    """ Writes PID to File """
    try:
        gutils.create_pidfile()
    except gutils.StillAliveException as e:
        log.debug('Sending SIGUSR1 to active instance: {}'.format(e.pid))
        os.kill(e.pid, signal.SIGUSR1)

        msg = 'Another instance of {} is already running. Terminating this instance.'
        raise RuntimeError(msg.format(NAME))


def xprintidle():
    """ Returns Machine's Current Idletime """
    out = sp.check_output(['xprintidle'])
    return int(out.decode())


def check_call(*args):
    """ Wrapper for subprocess.check_call """
    sp.check_call(args, stdout=DEVNULL, stderr=DEVNULL)


def term_handler(signum, frame):
    """ SIGTERM Handler """
    log.info('Terminated via SIGTERM signal.')
    sys.exit(0)


def usr1_handler(signum, frame):
    """ SIGUSR1 Handler """
    log.debug('Received SIGUSR1 signal.')
    load_args()


def load_args():
    """ Load args Variable from Data File """
    global args
    log.debug('Reloading args from: {}'.format(ARGSFILE))
    with open(ARGSFILE, 'rb') as f:
        args = pickle.load(f)
    log.debug('New args variable loaded: {}'.format(args))


def dump_args():
    """ Dump args Variable to Data File """
    log.debug('Dumping args variable to: {}'.format(ARGSFILE))
    with open(ARGSFILE, 'wb') as f:
        pickle.dump(args, f)


if __name__ == "__main__":
    idle_help = 'max amount of idletime (in minutes) to allow before stopping task'
    delay_help = 'time (in minutes) to delay between calls to xprintidle'
    waittime_help = 'time (in minutes) to wait for activity after stopping task'

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-i', dest='idletime', nargs='?', type=float, default=10, help=idle_help)
    parser.add_argument('-d', '--debug', action='store_true', help='enable debugging mode')
    parser.add_argument('-D', dest='delay', nargs='?', type=float, default=0.5, help=delay_help)
    parser.add_argument('-w', dest='waittime', nargs='?', type=float, default=30, help=waittime_help)
    args = parser.parse_args()

    if args.debug:
        gutils.logging.enableDebugMode(log)

    signal.signal(signal.SIGUSR1, usr1_handler)
    signal.signal(signal.SIGTERM, term_handler)

    try:
        dump_args()
        create_pidfile()
        main()
    except AssertionError as e:
        log.error(str(e))
        print('\n')
        parser.print_help()
        sys.exit(1)
    except RuntimeError as e:
        log.error(str(e))
        sys.exit(2)
    except Exception as e:
        log.error('{}: {}'.format(type(e).__name__, str(e)))
        raise
