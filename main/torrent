#!/usr/bin/python3

"""Script to make torrenting movies and TV shows easier (uses transmission as a backend).

Connects to a VPN (using Private Internet Access), downloads the torrent (using a magnet file),
disconnects from the VPN when the download is finished, and then sends me a text message to let
me know the download is complete.

Multiple torrents can be downloaded at the same time by simply running this script multiple times
(using different magnet files). If another instance of this script is running, the primary instance
will be signaled to enqueue the new magnet file for download.
"""

import atexit
import contextlib
import getpass
import os
import pickle
import threading
import time
import signal
import re
import subprocess as sp
import sys
import queue

import gutils

############################################################################################
#  gutils library: https://github.com/bbugyi200/pylibs/tree/master/gutils                  #
############################################################################################


class MagnetCounter:
    """Thread-Safe Counter of Magnet Files"""
    def __init__(self):
        self.lock = threading.Lock()
        self.count = 0

    def increment(self):
        with self.lock:
            self.count += 1
            return self.count


SECONDS_IN_HOUR = 3600
xdg_data_dir = gutils.xdg.init('data')
ARGS_FILE = '{}/args'.format(xdg_data_dir)

# Created after the first torrent is successfully added to transmission.
TSM_FILE = '{}/tsm_is_online'.format(xdg_data_dir)

log = gutils.logging.getEasyLogger(__name__)
magnet_counter = MagnetCounter()
magnet_queue = queue.Queue()
threads = []


def term_handler(signum, frame):
    """Remove All Magnet Files before Terminating"""
    log.debug('Terminated via {} signal.'.format(signal.Signals(signum).name))
    for i in range(1, magnet_counter.count + 1):
        remove_magnet(i)
    sys.exit(128 + signum)


def usr1_handler(signum, frame):
    """Adds New Magnet File to Queue"""
    log.debug('SIGUSR1 signal received.')
    with open(ARGS_FILE, 'rb') as f:
        args = pickle.load(f)

    wait_for_first_magnet()
    torrent(args)


def exit_handler():
    """Stop Transmission Daemon and Disconnect from VPN"""
    sp.Popen(['killall', '-9', 'transmission-daemon'], stdout=sp.DEVNULL, stderr=sp.STDOUT)
    sp.Popen(['PIA', 'stop'], stdout=sp.DEVNULL, stderr=sp.STDOUT)
    if os.path.exists(TSM_FILE):
        os.remove(TSM_FILE)


def main():
    atexit.register(exit_handler)

    signal.signal(signal.SIGTERM, term_handler)
    signal.signal(signal.SIGINT, term_handler)
    signal.signal(signal.SIGUSR1, usr1_handler)

    create_pidfile()
    time.sleep(args.delay)

    try:
        log.info('Connecting to VPN and starting transmission daemon...')
        sp.check_call(['PIA', 'start', args.vpn], stdout=sp.DEVNULL)
        sp.check_call(['sudo', 'chown', '-R', '{0}:{0}'.format(getpass.getuser()), args.download_dir])

        cmd_list = ['transmission-daemon']
        if args.debug:
            cmd_list.extend(['--log-debug', '-e', '/var/tmp/transmission.log'])
        sp.check_call(cmd_list, stdout=sp.DEVNULL)
    except sp.CalledProcessError:
        raise RuntimeError('Failed to start the VPN and/or the transmission daemon.')
    else:
        magnet_queue.maxsize = args.maxsize

        torrent(args)

        wait_for_first_magnet()
        magnet_queue.join()
        notify('All torrents are complete.')
    finally:
        sp.check_call(['sudo', 'chown', '-R', 'plex:plex', args.download_dir])


def torrent(args):
    """Creates new torrent thread worker. """
    t = threading.Thread(target=_torrent, args=(args,), daemon=True)
    t.start()
    threads.append(t)


def _torrent(args):
    """Thread worker

    Downloads the torrent given by the @magnet string.
    """
    log.debug('Adding "{}" to Magnet Queue...'.format(magnet_pprint(args.magnet)))
    magnet_queue.put(args.magnet)

    magnet_id = magnet_counter.increment()

    with gutils.logging.context(log, debug=args.debug, verbose=args.verbose), runtime_context():
        try:
            i = 0
            while True:
                time.sleep(1)
                try:
                    sp.check_call(['transmission-remote', '-a', args.magnet, '-w', args.download_dir], stdout=sp.DEVNULL)
                except sp.CalledProcessError:
                    i += 1
                    if i <= 10:
                        continue
                    else:
                        raise RuntimeError('Failed to start "{}".'.format(magnet_pprint(args.magnet)))
                else:
                    log.debug('Successfully added "{}".'.format(magnet_pprint(args.magnet)))
                    if not os.path.exists(TSM_FILE):
                        os.system('touch {}'.format(TSM_FILE))

                    break

            i = 0
            while True:
                SLEEP_TIME = 5

                i += 1
                if args.timeout:
                    if i > (args.timeout * SECONDS_IN_HOUR / SLEEP_TIME):
                        msg = "Torrent is still attempting to download \"{0}\" after {1:.1f} hour(s) "\
                              " elapsed time. Shutting down early.".format(magnet_pprint(args.magnet), args.timeout)
                        raise RuntimeError(msg)

                time.sleep(SLEEP_TIME)

                ps = sp.Popen(['transmission-remote', '-l'], stdout=sp.PIPE)
                out = ps.communicate()[0].decode()
                out_lines = [line.strip() for line in out.split('\n')]

                status_line = None
                for line in out_lines:
                    # Torrent status line may have a '*' next to the ID number
                    # if that torrent has a status of 'Stopped'.
                    if re.match(r'^{}\*?\s.*'.format(magnet_id), line):
                        status_line = line.lower()
                        break
                else:
                    raise RuntimeError(
                        'The magnet "{0}" (#{1}) has been lost somehow.\n\n'
                        '{2}\n'.format(magnet_pprint(args.magnet), magnet_id, '\n'.join(out_lines))
                    )

                if '100%' in status_line:
                    break

            gutils.notify('Finished Downloading "{}".'.format(magnet_pprint(args.magnet)))

        finally:
            remove_magnet(magnet_id)
            magnet_queue.get()
            magnet_queue.task_done()


@contextlib.contextmanager
def runtime_context():
    """RuntimeError Context Manager

    Context manager that makes sure users are notified of runtime exceptions.
    """
    try:
        yield
    except RuntimeError as e:
        notify(str(e))
        raise


def notify(msg):
    """Sends Desktop Notification and (possibly) SMS Notification"""
    log.debug('Sending notification to user.'.format(msg))
    gutils.notify('-t', '0', msg)
    if args.textme:
        sp.check_call(['textme', msg])


def remove_magnet(magnet_id):
    """Removes Transmission Magnet File"""
    try:
        sp.check_call(['transmission-remote', '-t{}'.format(magnet_id), '-r'], stdout=sp.DEVNULL)
        log.debug('Successfully removed magnet #{}.'.format(magnet_id))
    except sp.CalledProcessError:
        log.debug('Attempted to remove magnet #{} but it is NOT active.'.format(magnet_id))


def create_pidfile():
    """Duplicate Process Management"""
    try:
        gutils.create_pidfile()
    except gutils.StillAliveException as e:
        if not os.path.exists(TSM_FILE):
            while not os.path.exists(TSM_FILE):
                log.debug('{} does not exist yet. Waiting...'.format(TSM_FILE))
                time.sleep(1)

            time.sleep(1)

        with open(ARGS_FILE, 'wb') as f:
            pickle.dump(args, f)

        log.debug('Sending SIGUSR1 to {}.'.format(e.pid))
        os.kill(e.pid, signal.SIGUSR1)

        # Exit without invoking exit handler.
        os._exit(0)


def magnet_pprint(magnet):
    """Pretty print magnet string.

    Parses title out of magnet string.
    """
    match = re.search('&dn=(.*?)&', magnet)
    if match:
        return match.group(1)
    else:
        return 'UNKNOWN TITLE'


def wait_for_first_magnet():
    """Blocks until first magnet is added to queue."""
    while magnet_queue.empty():
        time.sleep(0.5)


if __name__ == "__main__":
    parser = gutils.ArgumentParser()
    parser.add_argument('magnet', help='The torrent magnet file.')

    default = '/media/bryan/hercules/media/Entertainment/Movies'
    parser.add_argument('-w', dest='download_dir', default=default,
                        help='The directory that the torrents will be downloaded to. Defaults to {}.'.format(default))

    default = 0
    parser.add_argument('-D', type=int, dest='delay', default=default,
                        help='Delay starting the script for DELAY seconds. Defaults to {}.'.format(default))

    default = 0
    parser.add_argument('-t', type=float, dest='timeout', default=default,
                        help='Time (in hours) to attempt to complete download before timing out. If set to 0, this script will run forever without ever timing out. Defaults to {}.'.format(default))

    parser.add_argument('-T', '--textme', dest='textme', action='store_true',
                        help='Forward notifications via SMS messages (i.e. enable text notifications).')

    default = 3
    parser.add_argument('--maxsize', dest='maxsize', default=default,
                        help='Max number of torrents allowed to download at one time (additional torrents will be enqueued and start when a space opens up). Defaults to {}.'.format(default))

    default = 'nyc'
    parser.add_argument('--vpn', dest='vpn', nargs='?', default=default,
                        help='VPN to connect to. Defaults to {}.'.format(default))

    args = parser.parse_args()


    with gutils.logging.context(log, debug=args.debug, verbose=args.verbose), runtime_context():
        main()
