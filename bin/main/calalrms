#!/usr/bin/env python

""" Set Alarms Based on Upcoming Khal Events """

import argparse
import atexit
import collections
import datetime as dt
import os
import signal
import subprocess as sp
import sys
import time

import gutils

log = gutils.logging.getEasyLogger(__name__)
RUNTIME_DIR = gutils.xdg.getdir('runtime')
PID_FILE = '{}/pid'.format(RUNTIME_DIR)
FIFO = '{}/fifo'.format(RUNTIME_DIR)
TOMORROW_MARKER = '@'


def main():
    end_date = dt.date.today() + dt.timedelta(days=2)
    end_date_string = end_date.strftime('%Y-%m-%d')

    raw_event_list = gutils.shell("khal list --notstarted --format '{{start-time}} {{title}}' now {}".format(end_date_string))

    if raw_event_list.startswith('No'):
        sys.exit(0)

    event_list = raw_event_list.split('\n')
    if 'Today' in event_list[0]:
        event_list = event_list[1:]
    log.debug('Event List: {}'.format(event_list))

    split_event_list = list(map(lambda event: event.split(maxsplit=1), event_list))
    log.debug('Split Event List: {}'.format(split_event_list))

    tomorrow_index = len(split_event_list)
    for i, event in enumerate(event_list):
        if 'Tomorrow, ' in event:
            tomorrow_index = i
            break

    marked_event_list = split_event_list[:tomorrow_index]
    marked_event_list.extend([['{}{}'.format(TOMORROW_MARKER, start), title] for start, title in split_event_list[tomorrow_index+1:]])
    log.debug('Marked Event List: {}'.format(marked_event_list))

    unique_events = collections.OrderedDict()
    for start1, _ in marked_event_list:
        if start1 not in unique_events:
            unique_events[start1] = set()
            for start2, title in marked_event_list:
                if start1 == start2:
                    unique_events[start1].add(title)

    log.debug('Unique Events: {}'.format(unique_events))

    for start, titles in unique_events.items():
        title = ' + '.join(titles)

        cmd_list = ['alarm']
        opts = []

        if start[0] == TOMORROW_MARKER:
            start = start[1:]
            opts.extend(['-T'])

        opts.extend([start, title])
        cmd_list.extend(opts)

        with open(FIFO, 'w') as fifo:
            log.debug('Writing "{}" to {}.'.format(title, FIFO))
            fifo.write('"{}" at {}\n'.format(title, start))

        try:
            sp.check_call(cmd_list)
        except sp.CalledProcessError as e:
            raise RuntimeError('Current alarm was interupted.')


def create_pidfile():
    """ Manages duplicate processes """
    try:
        gutils.create_pidfile()
    except gutils.StillAliveException as e:
        log.debug('Previous instance of {} is still alive. Sending SIGTERM...'.format(os.path.basename(__file__)))
        os.kill(e.pid, signal.SIGTERM)
        time.sleep(1)
        gutils.create_pidfile()


def mkfifo():
    """ Creates fifo if it does not already exist """
    try:
        os.mkfifo(FIFO)
        log.debug('Named Pipe {} Created.'.format(FIFO))
    except OSError as e:
        log.debug('Named Pipe {} Already Exists'.format(FIFO))
        pass


def exit(signum, frame):
    """ Signal Handler that Exits Gracefully """
    stop_alarm()
    sys.exit(1)


@atexit.register
def stop_alarm():
    """ Exit Handler """
    sp.call(['alarm', '--stop'])
    with open(FIFO, 'w') as fifo:
        fifo.write('\n')


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-d', '--debug', action='store_true', help='enable debugging mode')
    args = parser.parse_args()

    if args.debug:
        gutils.logging.enableDebugMode(log)

    signal.signal(signal.SIGTERM, exit)
    signal.signal(signal.SIGINT, exit)

    try:
        stop_alarm()
        create_pidfile()
        mkfifo()
        main()
    except RuntimeError as e:
        log.error(str(e))
        sys.exit(1)
    except Exception as e:
        log.error('{}: {}'.format(type(e).__name__, str(e)))
        raise
