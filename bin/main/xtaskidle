#!/usr/bin/env python

""" Stops Current TaskWarrior Task if Machine Idles for Too Long
and Restarts the Task when Activity Resumes """

import argparse
import logging
import os
import time
import subprocess as sp
import sys

from systemd.journal import JournalHandler

log = logging.getLogger(__name__)

max_help = 'max amount of idletime (in minutes) to allow before stopping task'
delay_help = 'time (in seconds) to delay between calls to xprintidle'
waittime_help = 'time (in minutes) to wait for activity after stopping task'

PIDFILE = "/tmp/{}.pid".format(os.path.basename(__file__))
MILLISECONDS_IN_MINUTE = 60000
DEVNULL = open(os.devnull, 'w')


def create_pidfile():
    """ Writes PID to File """
    if os.path.isfile(PIDFILE):
        old_pid = open(PIDFILE, 'r').read()
        try:
            os.kill(int(old_pid), 0)
        except OSError as e:
            pass
        except ValueError as e:
            if old_pid != '':
                raise
        else:
            msg = 'Another instance of {} is already running.'
            raise RuntimeError(msg.format(os.path.basename(__file__)))
    pid = os.getpid()
    open(PIDFILE, 'w').write(str(pid))


def xprintidle():
    """ Returns Machine's Current Idletime """
    out = sp.check_output(['xprintidle'])
    return int(out.decode())


def main():
    log.info('Starting...')

    MAX_IDLE = args.idletime * MILLISECONDS_IN_MINUTE
    MAX_WAIT = args.waittime * MILLISECONDS_IN_MINUTE

    while True:
        if xprintidle() >= MAX_IDLE:
            try:
                sp.check_call(['task', 'start.any:', 'stop'], stdout=DEVNULL, stderr=DEVNULL)
            except sp.CalledProcessError as e:
                raise RuntimeError('Failed to stop task. No task is currently started.')
        else:
            time.sleep(args.delay)
            continue

        log.info('Stopping current task...')
        while True:
            time.sleep(1)
            idletime = xprintidle()
            if idletime <= MAX_IDLE:
                log.info('Restarting last task...')
                sp.call(['last_task'], stdout=DEVNULL, stderr=DEVNULL)
                sp.call(['notify-send', sys.argv[0], 'The last active TaskWarrior task has been restarted.'])
                break
            elif idletime >= MAX_WAIT:
                log.info('Timed out. Terminating...')
                sys.exit(0)


if __name__ == "__main__":
    formatter = logging.Formatter('(%(asctime)s) [%(levelname)s] %(message)s',
                                  datefmt='%Y-%m-%d %H:%M:%S')
    sh = logging.StreamHandler()
    sh.setFormatter(formatter)
    sh.setLevel(logging.ERROR)
    jh = JournalHandler()
    jh.setFormatter(logging.Formatter('[%(levelname)s] %(message)s'))
    jh.setLevel(logging.INFO)
    fh = logging.FileHandler('/var/tmp/{}.log'.format(os.path.basename(__file__)))
    fh.setFormatter(formatter)
    fh.setLevel(logging.DEBUG)
    log.setLevel(logging.DEBUG)
    log.addHandler(sh)
    log.addHandler(jh)
    log.addHandler(fh)

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-i', dest='idletime', nargs='?', type=float, default=5, help=max_help)
    parser.add_argument('-d', '--debug', action='store_true', help='enable debugging mode')
    parser.add_argument('-D', dest='delay', nargs='?', type=int, default=30, help=delay_help)
    parser.add_argument('-w', dest='waittime', nargs='?', type=float, default=30, help=waittime_help)
    args = parser.parse_args()

    if args.debug:
        for handler in log.handlers:
            handler.setLevel(logging.DEBUG)

    try:
        assert (args.waittime > args.idletime), "Max wait time must be greater than max idletime."
        create_pidfile()
        main()
    except AssertionError as e:
        log.error(str(e))
        parser.print_usage()
        sys.exit(1)
    except RuntimeError as e:
        log.error(str(e))
        sys.exit(2)
    except Exception as e:
        log.error('{}: {}'.format(type(e).__name__, str(e)))
        raise
