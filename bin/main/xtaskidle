#!/usr/bin/env python

""" Stops Current TaskWarrior Task if Machine Idles for Too Long
and Restarts the Task when Activity Resumes """

import argparse
import os
import time
import subprocess as sp
import sys

max_help = 'max amount of idletime (in minutes) to allow before stopping task'
delay_help = 'time (in seconds) to delay between calls to xprintidle'
waittime_help = 'time (in minutes) to wait for activity after stopping task'
MILLISECONDS_IN_MINUTE = 60000
DEVNULL = open(os.devnull, 'w')


def xprintidle():
    """ Returns Machine's Current Idletime """
    out = sp.check_output(['xprintidle'])
    return int(out.decode())


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-t', '--idletime', nargs='?', type=float, default=5, help=max_help)
    parser.add_argument('-D', '--delay', dest='delay', nargs='?', type=int, default=30, help=delay_help)
    parser.add_argument('-w', '--waittime', dest='waittime', nargs='?', type=float, default=30, help=waittime_help)
    args = parser.parse_args()

    try:
        assert (args.waittime > args.idletime), "Max wait time must be greater than max idletime."
    except AssertionError as e:
        print('ERROR: {}\n'.format(str(e)))
        parser.print_help()
        sys.exit(1)

    MAX_IDLE = args.idletime * MILLISECONDS_IN_MINUTE
    MAX_WAIT = args.waittime * MILLISECONDS_IN_MINUTE

    while True:
        if xprintidle() >= MAX_IDLE:
            try:
                sp.check_call(['task', 'start.any:', 'stop'], stdout=DEVNULL, stderr=DEVNULL)
            except sp.CalledProcessError as e:
                time.sleep(args.delay*2)
                continue
        else:
            time.sleep(args.delay)
            continue

        while True:
            time.sleep(1)
            idletime = xprintidle()
            if idletime <= MAX_IDLE:
                sp.call(['last_task'], stdout=DEVNULL, stderr=DEVNULL)
                break
            elif idletime >= MAX_WAIT:
                break
