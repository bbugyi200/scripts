#!/usr/bin/env python

""" Stops Current TaskWarrior Task if Machine Idles for Too Long
and Restarts the Task when Activity Resumes """

import argparse
import datetime as dt
import logging
import os
import time
import signal
import subprocess as sp
import sys

import easylog

log = easylog.getEasyLogger(__name__)

NAME = os.path.basename(__file__)
PIDFILE = "/tmp/{}.pid".format(NAME)
MILLISECONDS_IN_MINUTE = 60000
DEVNULL = open(os.devnull, 'w')


def create_pidfile():
    """ Writes PID to File """
    if os.path.isfile(PIDFILE):
        old_pid = open(PIDFILE, 'r').read()
        try:
            os.kill(int(old_pid), 0)
        except OSError as e:
            pass
        except ValueError as e:
            if old_pid != '':
                raise
        else:
            msg = 'Another instance of {} is already running.'
            log.info(msg.format(NAME))
            kill(old_pid)
    pid = os.getpid()
    open(PIDFILE, 'w').write(str(pid))


def kill(pid):
    """ Send Kill Signal to PID """
    log.debug('Attempting to kill {}...'.format(pid))
    os.kill(int(pid), signal.SIGTERM)
    time.sleep(1)
    try:
        os.kill(int(pid), 0)
    except OSError as e:
        pass
    else:
        raise RuntimeError('Failed to kill old instance of {}.'.format(NAME))


def xprintidle():
    """ Returns Machine's Current Idletime """
    out = sp.check_output(['xprintidle'])
    return int(out.decode())


def check_call(*args):
    """ Wrapper for subprocess.check_call """
    sp.check_call(args, stdout=DEVNULL, stderr=DEVNULL)


def main():
    log.info('Starting {}.'.format(NAME))

    MAX_IDLE = args.idletime * MILLISECONDS_IN_MINUTE
    DELAY = args.delay * 60

    while True:
        idletime = xprintidle()
        if idletime >= MAX_IDLE:
            try:
                log.debug('System has been idle for {} milliseconds.'.format(idletime))
                log.info('Stopping current task...')
                check_call('task', 'start.any:', 'stop')
            except sp.CalledProcessError as e:
                raise RuntimeError('Failed to stop task. No task is currently started.')
        else:
            time.sleep(DELAY)
            continue

        dt_timeout = dt.datetime.now() + dt.timedelta(minutes=args.waittime)
        while True:
            time.sleep(1)
            idletime = xprintidle()
            if idletime <= MAX_IDLE:
                log.info('Restarting last task...')
                check_call('last_task')
                check_call('notify-send', NAME, 'The last active TaskWarrior task has been restarted.')
                break
            elif dt_timeout <= dt.datetime.now():
                log.info('Timed out after {} minutes of idle activity. Terminating {}.'.format(args.waittime, NAME))
                sys.exit(0)


if __name__ == "__main__":
    max_help = 'max amount of idletime (in minutes) to allow before stopping task'
    delay_help = 'time (in minutes) to delay between calls to xprintidle'
    waittime_help = 'time (in minutes) to wait for activity after stopping task'

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-i', dest='idletime', nargs='?', type=float, default=5, help=max_help)
    parser.add_argument('-d', '--debug', action='store_true', help='enable debugging mode')
    parser.add_argument('-D', dest='delay', nargs='?', type=float, default=0.5, help=delay_help)
    parser.add_argument('-w', dest='waittime', nargs='?', type=float, default=30, help=waittime_help)
    args = parser.parse_args()

    if args.debug:
        for handler in log.handlers:
            handler.setLevel(logging.DEBUG)

    try:
        assert (args.waittime > args.idletime), "Max wait time must be greater than max idletime."
        create_pidfile()
        main()
    except AssertionError as e:
        log.error(str(e))
        print('\n')
        parser.print_help()
        sys.exit(1)
    except RuntimeError as e:
        log.error(str(e))
        sys.exit(2)
    except Exception as e:
        log.error('{}: {}'.format(type(e).__name__, str(e)))
        raise
