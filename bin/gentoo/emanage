#!/usr/bin/env python

"""Interface for System Maintenance Tasks"""

import datetime as dt
import os
import random
import string
import subprocess as sp  # noqa: F401
import sys

import gutils

#######################################################################################
#  gutils library: https://github.com/bbugyi200/scripts/tree/master/pymodules/gutils  #
#######################################################################################

log = gutils.logging.getEasyLogger(__name__)
scriptname = os.path.basename(os.path.realpath(__file__))


def main():
    cmd_list = []
    if args.update:
        cmd = 'eupdate'
    elif args.cleanup:
        cmd = 'ecleanup'
    elif args.maint_check:
        cmd = 'emaint_check'

    cmd_list.append(cmd)
    data_dir = gutils.xdg.getdir('data')
    local_hostname = os.uname().nodename
    local_tsfile = '{}/{}/{}.timestamp'.format(data_dir, local_hostname, cmd)

    if args.pretend:
        print(cmd)
        sys.exit(0)
    elif args.dsl:
        if args.dsl == 'local':
            out = sp.check_output(['edsl', local_tsfile])
            print(out.decode().strip())
        elif args.dsl == 'remote':
            remote_hostnames = [H for H in os.listdir(data_dir) if H != local_hostname]
            remote_ts_files = ['{}/{}/{}.timestamp'.format(data_dir, H, cmd)
                               for H in remote_hostnames]

            for H, fp in zip(remote_hostnames, remote_ts_files):
                out = sp.check_output(['edsl', fp])
                print('{}:{}'.format(H, out.decode().strip()))

        sys.exit(0)

    # Just used to force myself to use emanage. :)
    # Requires that the secret.sh file be sourced into every script that could be called here.
    secret_fp = '/tmp/{}.secret'.format(scriptname)
    secret = get_secret(secret_fp)
    cmd_list.extend([secret_fp, secret])

    sp.check_call(cmd_list)

    if cmd != 'emaint_check':
        write_timestamp(local_tsfile, cmd)


def write_timestamp(fp, cmd):
    """Writes Timestamp to a File"""
    dp = os.path.dirname(fp)
    if not os.path.exists(dp):
        os.makedirs(dp)

    with open(fp, 'w') as f:
        now = dt.datetime.now()
        f.write(now.strftime('%m/%d/%Y'))


def get_secret(fp):
    secret = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(16))
    log.vdebug('secret: %s', secret)
    with open(fp, 'w') as f:
        f.write(secret)
    return secret


if __name__ == "__main__":
    parser = gutils.ArgumentParser()
    ex_group = parser.add_mutually_exclusive_group()
    ex_group.add_argument('-u', '--update', dest='update', action='store_true',
                         help='Update the machine.')
    ex_group.add_argument('-c', '--cleanup', dest='cleanup', action='store_true',
                         help='Run cleanup tasks.')
    ex_group.add_argument('-m', '--maint-check', dest='maint_check', action='store_true',
                         help='Check if any maintenance is due.')

    ex_group2 = parser.add_mutually_exclusive_group()
    ex_group2.add_argument('-D', '--days-since-last', dest='dsl', choices=['local', 'remote'],
                        help='Prints the number of days its been since the timestamp was written. '
                             'This option takes an argument indicating what machine(s) to check. '
                             '"local" indicates the local machine and "remote" indicates all '
                             'remote machines.')
    ex_group2.add_argument('-P', '--pretend', dest='pretend', action='store_true',
                        help='Prints the command list instead of executing it.')
    args = parser.parse_args()

    with gutils.logging.context(log, debug=args.debug, verbose=args.verbose):
        main()
