#!/usr/bin/env python

"""Used to automate the demonstration of a terminal program for the purpose of creating a GIF

Automates keypresses with xdotool by reading from a simple text file. Sends most text to `xdotool
type` but also uses various "flags" embedded in the text to indicate that some event should occur
at the point the flag was found.

Flags:
    newline:    At every new line, `xdotool key KP_Enter` is run. Execution then sleeps
                for a default amount of time. This can be changed by using a <<N>> marker
                at the start of a newline. This will overwrite (NOT add to) the default
                "enter key delay" for this line only.
    [KEY]:      Emulate some special key-press using `xdotool key`. KEY is used to represent
                a template value to be replaced by a valid value (i.e. [KEY] is not a valid flag).
                Valid key flags: [ESC] [TAB] [CLEAR]
    <<N>>:      Run time.sleep(N).
    ((N)):      Alter the --delay parameter for `xdotool type`. This persists to the end
                of the line (or until the next ((N))) marker is reached). The next line
                uses the default --delay value.
"""

import re
import subprocess as sp  # noqa: F401
import time

import gutils

#######################################################################################
#  gutils library: https://github.com/bbugyi200/scripts/tree/master/pymodules/gutils  #
#######################################################################################

log = gutils.logging.getEasyLogger(__name__)


def xtype(keys, *, delay=None):
    """Wrapper for `xdotool type`

    Args:
        keys (str): Keys to type.
        delay (optional): Typing delay.
    """
    if delay is None:
        delay = 150

    keys = keys.strip('\n')

    log.debug('xdotool type --delay {} {}'.format(delay, keys))
    sp.check_call(['xdotool', 'type', '--delay', str(delay), keys])


def xkey(key):
    """Wrapper for `xdotool key`"""
    sp.check_call(['xdotool', 'key', key])


def interpret_line(line, typedelay=None):
    """Recursive function to interpret a single line by parsing through the defined flags.

    Args:
        line (str): A line from the demo text file.
        typedelay (optional): Delay arg for xtype. Needed to preserve state while when making
            recursive calls.
    """
    pttrn_fmt = r'(<<[0-9\.]+>>|\(\([0-9\.]+\)\)|{})'
    key_flag_pairs = [('ESC', 'Escape'), ('CLEAR', 'ctrl+u'), ('TAB', 'Tab')]
    key_flag_pttrn = '|'.join([r'\[{}\]'.format(flag) for flag, _ in key_flag_pairs])
    pttrn = pttrn_fmt.format(key_flag_pttrn)

    flag = re.search(pttrn, line)
    while flag:
        interpret_line(line[:flag.start()], typedelay=typedelay)
        group = flag.groups()[0]

        for key_flag, key in key_flag_pairs:
            if group == '[{}]'.format(key_flag):
                xkey(key)
                break

        # these checks are only relevant if no key_flag was identified
        if group[:2] == '<<':
            time.sleep(float(group.strip('<>')))
        elif group[:2] == '((':
            typedelay = group.strip('()')

        line = line[flag.end():]

        flag = re.search(pttrn, line)

    # Normal `xdotool type` if no flags are found/left.
    xtype(line, delay=typedelay)


if __name__ == "__main__":
    parser = gutils.ArgumentParser()
    parser.add_argument('file', nargs='?', default='demo.txt', help='The file to read from.')
    parser.add_argument('-E', '--enter-delay', nargs=1, dest='enter_delay', default=1,
            help='How many seconds to sleep after pressing Enter.')
    args = parser.parse_args()

    with gutils.logging.context(log, debug=args.debug):
        time.sleep(0.5)
        first = True
        for line in open(args.file, 'r'):
            if line[0] == '#' or line[:2] == '//':
                continue
            if not first:
                enter_delay_match = re.search(r'^<<([0-9\.]+)>>', line)
                if enter_delay_match:
                    enter_delay = enter_delay_match.groups()[0]
                    line = line[enter_delay_match.end():]
                else:
                    enter_delay = args.enter_delay

                xkey('KP_Enter')
                time.sleep(float(enter_delay))
            else:
                first = False

            interpret_line(line)
