#!/usr/bin/env python

"""Automates keypresses with xdotool by reading from a simple text file

Sends most text to `xdotool type` but also uses various "flags" to indicate that some
event should occur at that point.

Flags:
    newline:     At every new line, `xdotool key KP_Enter` is run. Execution then sleeps
                 for a default amount of time. This can be changed by using a <<N>> marker
                 at the start of a newline. This will overwrite (NOT add to) the default
                 "enter key delay" for this line only.
    @:          Run `xdotool key Escape`.
    <<N>>:      Run time.sleep(N).
    ((N)):      Alter the --delay parameter for `xdotool type`. This persists to the end
                of the line (or until the next ((N))) marker is reached). The next line
                uses the default --delay value.
"""

import re
import subprocess as sp  # noqa: F401
import time

import gutils

log = gutils.logging.getEasyLogger(__name__)


def xtype(string, *, delay=None):
    if delay is None:
        delay = 150

    string = string.strip('\n')

    log.debug('xdotool type --delay {} {}'.format(delay, string))
    sp.check_call(['xdotool', 'type', '--delay', str(delay), string])


def xkey(key):
    sp.check_call(['xdotool', 'key', key])


def read_line(line, typedelay=None):
    while True:
        log.debug('Line at start of loop: {}'.format(line))
        start_match = re.search(r'^\(\(([0-9]+)\)\)', line)

        if start_match:
            log.debug('Start Match: {}'.format(start_match.group()))
            typedelay = start_match.groups()[0]
            if start_match:
                start = start_match.end()
            else:
                start = 0
        else:
            log.debug('No start match found.')
            start = 0
            typedelay = typedelay

        line = line[start:]

        while True:
            flag = re.search(r'(<<[0-9\.]+>>|@|\[CLEAR\]|\[TAB\])', line)
            if flag:
                read_line(line[:flag.start()], typedelay=typedelay)
                group = flag.groups()[0]

                if group == '@':
                    xkey('Escape')
                elif group == '[CLEAR]':
                    xkey('ctrl+u')
                elif group == '[TAB]':
                    xkey('Tab')
                else:
                    time.sleep(float(flag.groups()[0].strip('<>')))

                line = line[flag.end():]
                continue
            break

        end_match = re.search(r'\(\(([0-9]+)\)\)', line)
        if not end_match:
            end_match = re.search(r'<<[0-9]+>>', line)

        log.debug('Line at middle of loop: {}'.format(line))
        if end_match:
            log.debug('End Match: {}'.format(end_match.group()))
            end = end_match.start()
        else:
            log.debug('No end match found.')
            end = len(line)

        xtype(line[:end], delay=typedelay)

        line = line[end:]
        log.debug('Line at end of loop: {}'.format(line))
        if not end_match:
            return


if __name__ == "__main__":
    parser = gutils.ArgumentParser()
    parser.add_argument('file', nargs='?', default='demo.txt', help='The file to read from.')
    parser.add_argument('-E', '--enter-delay', nargs=1, dest='enter_delay', default=1,
            help='How many seconds to sleep after pressing Enter.')
    args = parser.parse_args()

    with gutils.logging.context(log, debug=args.debug):
        time.sleep(0.5)
        first = True
        for line in open(args.file, 'r'):
            if line[0] == '#' or line[:2] == '//':
                continue
            if not first:
                enter_delay_match = re.search(r'^<<([0-9\.]+)>>', line)
                if enter_delay_match:
                    enter_delay = enter_delay_match.groups()[0]
                    line = line[enter_delay_match.end():]
                else:
                    enter_delay = args.enter_delay

                xkey('KP_Enter')
                time.sleep(float(enter_delay))
            else:
                first = False

            read_line(line)
