#!/bin/bash

#########################################
#  Create a Patch for a Gentoo Package  #
#########################################

source /home/bryan/Dropbox/scripts/templates/gutils.sh

# ensure running as root
if [ "$(id -u)" != "0" ]; then
  exec sudo "$0" -u "$USER" "$@"
fi

USAGE="usage: $(basename "$0") [-h] [-d] [-a PATCH | -I | [-V] -i PATCH | -l | -P | -r PATCH | [-o OVERLAY] PACKAGE]"
OVERLAY="gentoo"
TMP_DIR=/tmp/"$(basename "$0")"

eval set -- "$(getopt -o "a:,d,h,I,i:,l,o:,P,r:,V,u:" -l "apply:,debug,help,install-pkg,install:,list,overlay:,purge,remove:,use-version-specifier,user:" -- "$@")"

read -r -d '' HELP << EOM
$USAGE

Steps to create an ebuild patch:

1) Run \`cd \$(epatch PACKAGE)\` (will cd to temp working directory).
2) Make your code changes.
3) Run \`epatch -i PATCH\` (while still in the temp working directory) to install PATCH.patch.
EOM

while [[ -n "$1" ]]; do
    case $1 in
       -a|--apply )
           shift
           PATCH_NAME="$1"
           apply=true
           ;;
       -d|--debug )
           debug=true
           PS4='$LINENO: '
           set -x
           ;;
       -h|--help )
           echo "$HELP"
           exit 0
           ;;
       -I|--install-pkg )
           install_pkg=true
           ;;
       -i|--install )
           shift
           PATCH_NAME="$1"
           install=true
           ;;
       -l|--list )
           list=true
           ;;
       -o|--overlay )
           shift
           OVERLAY="$1"
           ;;
       -P|--purge )
           purge=true
           ;;
       -r|--remove )
           shift
           PATCH_NAME="$1"
           remove=true
           ;;
       -u|--user )
           shift
           REGULAR_USER="$1"
           ;;
       -V|--use-version-specifier )
           use_version_specifier=true
           ;;
       -- )
           shift
           break
           ;;
    esac
    shift
done

# ---------- Apply (-a) and Install (-i) Handlers ----------
if [[ "$apply" = true || "$install_pkg" = true || "$install" = true || "$list" = true || "$purge" = true || "$remove" = true ]] ; then
    quick_action=true

    if ! [[ "$(pwd)" =~ "$TMP_DIR"/[^/]*/.* ]]; then
        echo "ERROR: cannot use -a, -I, -i, -l, -r, or -P options outside of $TMP_DIR/CATEGORY/PACKAGE"
        exit 1
    fi

    PATCH_SUBDIR="$(pwd | awk -F'/' '{printf "%s/%s", $4, $5}')"
    PATCH_DIR=/etc/portage/patches/"$PATCH_SUBDIR"
    PATCH_PATH="$PATCH_DIR"/"$PATCH_NAME".patch

    if [[ "$PATCH_DIR" =~ .*\/[A-Za-z\-]+\-[0-9]+ ]]; then
        PATCH_NOVERSION_DIR="${PATCH_DIR%-*}"
    else
        PATCH_NOVERSION_DIR="$PATCH_DIR"
    fi

    PATCH_NOVERSION_PATH="$PATCH_NOVERSION_DIR"/"$PATCH_NAME".patch
fi

if [[ "$apply" = true ]]; then
    [[ -f "$PATCH_PATH" ]] || die "The patch $PATCH_PATH does NOT exist."
    git apply "$PATCH_PATH"
    emsg "Applied $PATCH_NAME.patch to git repository."
elif [[ "$install_pkg" = true ]]; then
    get -f "$(pwd | awk -F'/' '{printf "%s", $5}')"
elif [[ "$install" = true ]]; then
    if [[ "$use_version_specifier" ]]; then
        PDIR="$PATCH_DIR"
        PPATH="$PATCH_PATH"
    else
        PDIR="$PATCH_NOVERSION_DIR"
        PPATH="$PATCH_NOVERSION_PATH"
    fi

    [[ -d "$PDIR" ]] || mkdir -p "$PDIR"

    git diff > "$PPATH"
    emsg "Installed patch to $PPATH."
elif [[ "$list" = true ]]; then
    find "$PATCH_DIR" "$PATCH_NOVERSION_DIR" -name "*.patch" 2> /dev/null
elif [[ "$purge" = true ]]; then
    git reset --hard HEAD &> /dev/null
    git clean -f &> /dev/null
    emsg "Purged all patches from git repository."
elif [[ "$remove" = true ]]; then
    if ! [[ -f "$PATCH_PATH" ]] && ! [[ -f "$PATCH_NOVERSION_PATH" ]]; then
        die "No patch by the name of $PATCH_NAME.patch currently exists."
    fi

    if [[ -f "$PATCH_PATH" ]]; then
        rm "$PATCH_PATH"
        emsg "Removed $PATCH_PATH."
    fi

    if [[ -f "$PATCH_NOVERSION_PATH" ]]; then
        rm "$PATCH_NOVERSION_PATH"
        emsg "Removed $PATCH_NOVERSION_PATH."
    fi
fi

if [[ "$quick_action" = true ]]; then
    exit 0
fi

# ---------- Main ----------
if [[ -z "$1" ]]; then
    echo "$USAGE"
    exit 2
fi

PN="$1"; shift

OVERLAY_PATH="$(portageq get_repo_path / "$OVERLAY")"
EBUILD_CHOICES_RAW="$(find "$OVERLAY_PATH" -type f -regex ".*/$PN/.*\.ebuild" | tr '\n' ' ')"

if [[ -z "$EBUILD_CHOICES_RAW" ]]; then
    echo "ERROR: unable to find the package $PN::$OVERLAY." | tee >(logger -t "$(basename "$0")")
    exit 1
fi

IFS=' ' read -r -a EBUILD_CHOICES <<< "$EBUILD_CHOICES_RAW"

if [[ "${#EBUILD_CHOICES[@]}" -eq 1 ]]; then
    EBUILD="${EBUILD_CHOICES[0]}"
else
    PS3=$'\n'"Select an ebuild to patch: "
    select EBUILD in "${EBUILD_CHOICES[@]}"; do
        case "$EBUILD" in
            * )
                break
                ;;
        esac
    done
fi

P="$(basename "${EBUILD%.ebuild}")"

# Removes revision number from ${P}
if [[ "$P" =~ .*-r[0-9]+ ]]; then
    P="${P%-r*}"
fi

# Disables STDOUT and STDERR
if [[ "$debug" != true ]]; then
    exec 5>&1 > /dev/null
    exec 2>&1
fi

ebuild "$EBUILD" clean unpack

PORTAGE_BUILD_DIR=/var/tmp/portage
WORK_DIR="$(find "$PORTAGE_BUILD_DIR" -type d -regex ".*/work/${P}[^/]*")"

CATEGORY="$(echo "${WORK_DIR#$PORTAGE_BUILD_DIR}" | awk -F'/' '{print $2}')"

TMP_WORK_DIR="$TMP_DIR"/"$CATEGORY"
TMP_WORK_DIR="$TMP_WORK_DIR"/"$P"

[[ -d "$TMP_WORK_DIR" ]] || mkdir -p "$TMP_WORK_DIR"
cp -r "$WORK_DIR"/* "$TMP_WORK_DIR"

cd "$TMP_WORK_DIR" || exit 1
git init
git add .
git commit -m "Initial Commit"

chown -R "$REGULAR_USER":"$REGULAR_USER" "$TMP_DIR"

if [[ "$debug" != true ]]; then
    exec 1>&5  # Restores STDOUT
fi
printf "$TMP_WORK_DIR"
