#!/bin/zsh

# Refreshes vim by reopening the file and then brings cursor to the bottom
refresh_notes() {
	if tmux send-keys -t notes:0.0 ":e" Enter "G"; then
		:
	else
		tmux send-keys -t $abbrv:0.0 ":e" Enter "G"
	fi
}

# ---------- Command Line Arguments ----------
eval set -- $(getopt -o "odubc:p:" -l "open,debug,undo,bottom,cut:,put:,dmenu" -- "$@")

putarg=
debug=0
dmenu=0
bottom=0
cut="suffix+prefix"
while [[ -n "$1" ]]; do
	case $1 in
		'-o' | '--open' )
			action="open";;
		'-d' | '--debug' )
			debug=1;;
		'-u' | '--undo' )
			action="undo";;
		'-b' | '--bottom' )
			bottom=1;;
		'-c' | '--cut' )
			shift
			cut="$1";;
		'-p' | '--put' )
			shift
			action="put"
			putarg="$1";;
		'--dmenu' )
			dmenu=1;;
		'--' )
			shift
			break;;
	esac
	shift
done


# ---------- Variable Initializations ----------
# Retrieves the basename of the pdf (minus the ".pdf" suffix)
base=$(basename "$1")
base=${base// /_}
base=${base%.pdf}

# Abbreviation for book (used for tmux session name)
abbrv=$(echo $base | sed -e 's/\([A-Z]\)[A-Z]*/\1/g; s/[a-z \.\_-]//g; s/(.*)//g')

# Full path to text file that stores my notes for this book
fpath="/home/bryan/Dropbox/notes/Study/${base}.txt"

# Escaped file path (for use on command line)
esc_fpath=$(printf "%q" $fpath)


# ---------- Kill stdout and stderr ----------
if [[ $debug -eq 0 ]]; then
	exec 2>&1
	exec 1> /dev/null
fi

# ---------- Handle Actions ----------
case $action in
	'open')
		if [[ $bottom -eq 1 ]]; then
			bspc node -p south -o 0.8
			termite --title="notes" --class="notes" -e "tm-init notes" &
			sleep 0.5
			tmux send-keys -t notes:0.0 "vim + $esc_fpath" Enter
		else
			tmux send-keys "tm $abbrv" Enter
			sleep 0.5
			tmux send-keys -t $abbrv:0.0 "vim -c'?---' $esc_fpath" Enter "zt"
			wmctrl -a termite
		fi;;
	'undo')
		sed -i'.backup' ':a; ${d; q}; N; /\n$/!ba' $fpath
		sed -i '$d' $fpath
		refresh_notes;;
	'put')
		# gets current page number
		page=$(wmctrl -l | grep $base | tr -s ' ' | cut -d ' ' -f5 | cut -d'[' -f2 | cut -d'/' -f1 | head -1)

		# if '--dmenu' was used, clip is set using dmenu input
		if [[ $dmenu -eq 1 ]]; then
			clip=$(echo | dmenu -p "notepad ($putarg):")
		# else the contents of the clipboard are used
		else
			clip=$(xclip -selection clipboard -o)

			# Remove newlines
			clip=$(echo $clip | tr '\n' ' ')

			# Remove partial sentence at beginning of clip
			if [[ $cut == *"prefix"* ]] && [[ $clip == [a-z,' ']* ]]; then
					clip=${clip#*. }
			fi

			# Remove partial sentence at end of clip
			if [[ $cut == *"suffix"* ]] && [[ $clip == *[A-Z]*"."* ]]; then
				if [[ $clip == *[A-Za-z,' '] ]]; then
					clip="${clip%.*}."
				fi
			fi

			# Enclose clip in quotes
			clip="\"${clip}\""
		fi

		# Inserts newline in clip every 80 characters
		clip=$(echo $clip | fold -w80 -s)

		if [[ -z "$clip" ]]; then
			logger "notepad: 'clip' variable is empty"
			exit 1
		fi

		if [[ $putarg == "major" ]]; then
			printf "\n" >> $fpath
		elif [[ $putarg == "minor" ]]; then
			printf "  * " >> $fpath

			# Replaces every '\n' in clip with '\n     '
			clip=$(echo -n $clip | sed ':a;N;$!ba;s/\n/\n    /g')
		else
			logger "notepad: Unacceptable value ('putarg' = $putarg)"
			exit 1
		fi

		echo -n $clip >> $fpath 
		printf " - p%s\n" $page >> $fpath
		
		refresh_notes
		;;
esac
