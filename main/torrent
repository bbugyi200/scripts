#!/usr/bin/env python3

"""Script to make torrenting movies and TV shows easier (wraps a P2P client).

Connects to a VPN (using Private Internet Access), downloads the torrent (using a magnet file),
disconnects from the VPN when the download is finished, and then sends me a text message to let
me know the download is complete.

Multiple torrents can be downloaded at the same time by simply running this script multiple times
(using different magnet files). If another instance of this script is running, the primary instance
will be signaled to enqueue the new magnet file for download.
"""

import argparse
import atexit
import contextlib
import getpass
import os
from pathlib import Path
import pickle
import queue
import re
import signal
import subprocess as sp
import sys
import threading
import time
from types import FrameType
from typing import (  # noqa
    Any,
    Callable,
    Container,
    Dict,
    Generator,
    Iterable,
    Iterator,
    List,
    NoReturn,
    Optional,
    Sequence,
    Set,
    Tuple,
    TypeVar,
    Union,
)

import gutils

# This lock "protects" (i.e. blocks) the torrents from "catching the Plague"
# (i.e. removing themselves from the BitTorrent client) immediately after
# download.  Instead, they seed until the very last torrent finishes
# downloading, at which point all torrents "become infected" and die, one after
# the other.
the_plague = threading.Lock()


class MagnetTracker:
    """Thread-Safe Counter of Magnet Files"""
    def __init__(self):
        self.lock = threading.Lock()

        self.ids: Dict[int, str] = {}
        self.next_key = 0  # used to index into `self.ids`
        self.active_torrents = 0

        # I have trapped the plague in Pandora's Box. It is contained... for now.
        the_plague.acquire()

    def __getitem__(self, i: int) -> str:
        return self.ids[i]

    def done(self) -> int:
        """Called everytime a torrent finishes downloading."""
        with self.lock:
            self.active_torrents -= 1

            if self.active_torrents == 0:
                # Release the plague upon the world!
                # May God have mercy on any torrent that still draws breath! ;(
                the_plague.release()

            return self.active_torrents

    def new(self, id_list: List[str]) -> int:
        """Captures ID of new torrent.

        Returns:
            An integer key that can be used to retrieve the torrent's ID
            (by indexing into `self.ids`).
        """
        log.vdebug("id_list = %s", id_list)  # type: ignore
        with self.lock:
            self.next_key += 1
            self.active_torrents += 1

            for ID in id_list:
                if ID in self.ids.values():
                    continue
                else:
                    self.ids[self.next_key] = ID
                    break
            else:
                raise RuntimeError(
                    'Something has gone wrong. '
                    'All Magnet IDs appear to have been used already.'
                )

            return self.next_key


XDG_DATA_DIR = gutils.xdg.init('data')
ARGS_FILE = XDG_DATA_DIR / 'args'
# Created after the first torrent is successfully added to P2P client.
MASTER_IS_ONLINE_FILE = XDG_DATA_DIR / 'master_is_online'
DELUGE = ['sudo', '-E', 'deluge-console']

log = gutils.logging.getEasyLogger(__name__)
mtracker = MagnetTracker()
mqueue: 'queue.Queue[str]' = queue.Queue()


def main(args: argparse.Namespace) -> None:
    def exit_handler() -> None:
        """Stop P2P Daemon and disconnect from VPN."""
        sp.Popen(['sudo', 'killall', 'deluged'])
        sp.Popen(['sudo', 'killall', 'deluge-web'])

        sp.Popen(['PIA', 'stop'])

        if MASTER_IS_ONLINE_FILE.exists():
            MASTER_IS_ONLINE_FILE.unlink()

    def term_handler(signum: signal.Signals, frame: FrameType) -> None:
        """Remove all magnet files before terminating."""
        log.debug('Terminated via {} signal.'.format(signal.Signals(signum).name))
        kill_all_torrents()  # Remove any torrents still seeding / downloading on P2P client.
        sys.exit(128 + signum)

    def usr1_handler(signum: signal.Signals, frame: FrameType) -> None:
        """Add new magnet file to queue."""
        log.debug('SIGUSR1 signal received.')
        with ARGS_FILE.open('rb') as f:
            args = pickle.load(f)

        wait_for_first_magnet()
        new_torrent_worker(args)

    def new_torrent_worker(args: argparse.Namespace) -> None:
        """Creates new torrent thread worker."""
        thread = threading.Thread(target=torrent_worker, args=(args,), daemon=True)
        thread.start()

    def wait_for_first_magnet() -> None:
        """Blocks until first magnet is added to queue."""
        while mqueue.empty():
            time.sleep(0.5)

    atexit.register(exit_handler)

    signal.signal(signal.SIGTERM, term_handler)
    signal.signal(signal.SIGINT, term_handler)
    signal.signal(signal.SIGUSR1, usr1_handler)

    create_pidfile(args)
    time.sleep(args.delay)

    try:
        log.info('Connecting to VPN and starting P2P client daemon...')
        sp.check_call(['PIA', 'start', args.vpn])
        sp.check_call(['sudo', 'chown', '-R', '{0}:{0}'.format(getpass.getuser()), args.download_dir])

        cmd_list = ['sudo', '-E', 'deluged']
        sp.check_call(cmd_list)

        cmd_list = ['sudo', '-E', 'deluge-web', '--fork']
        sp.check_call(cmd_list)

        # Remove any torrents that might have been saved from your
        # last P2P session.
        kill_all_torrents()
    except sp.CalledProcessError:
        raise RuntimeError('Failed to start the VPN and/or the P2P client daemon.')
    else:
        mqueue.maxsize = args.maxsize

        new_torrent_worker(args)

        wait_for_first_magnet()
        mqueue.join()
        notify_and_log('All torrents are complete.')
    finally:
        sp.check_call(['sudo', 'chown', '-R', 'plex:plex', args.download_dir])


def create_pidfile(args: argparse.Namespace) -> None:
    """Duplicate Process Management"""
    try:
        gutils.create_pidfile()
    except gutils.StillAliveException as e:
        if not MASTER_IS_ONLINE_FILE.exists():
            while not MASTER_IS_ONLINE_FILE.exists():
                log.debug('{} does not exist yet. Waiting...'.format(MASTER_IS_ONLINE_FILE))
                time.sleep(1)

            time.sleep(1)

        with ARGS_FILE.open('wb') as f:
            pickle.dump(args, f)

        log.debug('Sending SIGUSR1 to {}.'.format(e.pid))
        os.kill(e.pid, signal.SIGUSR1)

        # Exit without invoking exit handler.
        os._exit(0)


def torrent_worker(args: argparse.Namespace) -> None:
    """Thread Worker

    Downloads the torrent given by the @args.magnet string.
    """
    @contextlib.contextmanager
    def notify_context() -> Generator:
        try:
            yield
        except RuntimeError as e:
            notify_and_log(str(e))
            raise

    def prettify_magnet() -> str:
        match = re.search('&dn=(.*?)&', args.magnet)
        if match:
            return match.group(1)
        else:
            return 'UNKNOWN TITLE'

    log.debug('Adding "{}" to Magnet Queue...'.format(prettify_magnet()))
    mqueue.put(args.magnet)

    download_started = False
    with gutils.logging.context(log, debug=args.debug, verbose=args.verbose), notify_context():
        try:
            i = 0
            while True:
                time.sleep(1)
                try:
                    sp.check_call(DELUGE + ['add', '-p', args.download_dir, args.magnet])
                except sp.CalledProcessError:
                    i += 1
                    if i <= 10:
                        continue
                    else:
                        raise RuntimeError('Failed to start "{}".'.format(prettify_magnet()))
                else:
                    log.debug('Successfully added "{}".'.format(prettify_magnet()))

                    try:
                        id_list = [ID.split()[1] for ID in run_info_cmd('ID')]
                        mkey = mtracker.new(id_list)
                    except ValueError:
                        raise RuntimeError(
                            'Something is not right. The torrent has been added '
                            'to the P2P client but `run_info_cmd(ID)` has somehow failed.'
                        )

                    if not MASTER_IS_ONLINE_FILE.exists():
                        MASTER_IS_ONLINE_FILE.touch()

                    break

            i = 0
            while True:
                SLEEP_TIME = 5

                i += 1
                if args.timeout:
                    SECONDS_IN_HOUR = 3600
                    if i > (args.timeout * SECONDS_IN_HOUR / SLEEP_TIME):
                        msg = "Torrent is still attempting to download \"{0}\" after {1:.1f} hour(s) "\
                              " elapsed time. Shutting down early.".format(prettify_magnet(), args.timeout)
                        raise RuntimeError(msg)

                time.sleep(SLEEP_TIME)

                full_state = run_info_cmd('State', ID=mtracker[mkey])

                state = str(full_state).split()[1]
                if state == 'Downloading':
                    download_started = True
                elif state == 'Seeding' or (state == 'Queued' and download_started):
                    break

            notify_and_log('Finished Downloading "{}".'.format(prettify_magnet()))

        finally:
            mtracker.done()

            with the_plague:
                # The plague has been released!
                # So be it! We shall all die together!
                kill_torrent(mtracker[mkey])

                mqueue.get()
                mqueue.task_done()


def kill_all_torrents() -> None:
    """Kill everyone (all torrents anyway).

    i.e. each torrent will be removed from the P2P client.
    """
    try:
        full_id_list = run_info_cmd('ID')
        log.vdebug("full_id_list = %s", full_id_list)  # type: ignore
    except ValueError:
        return

    all_ids = [ID.split()[1] for ID in full_id_list]
    for ID in all_ids:
        kill_torrent(ID)


def kill_torrent(ID: str) -> None:
    """Remove torrent specified by @ID from the P2P client."""
    try:
        sp.check_call(DELUGE + ['rm', ID])
        log.debug('Successfully removed magnet #{}.'.format(ID))
    except sp.CalledProcessError:
        log.debug('Attempted to remove magnet #{} but it is NOT active.'.format(ID))


def run_info_cmd(field: str, ID: str = None) -> Union[str, List[str]]:
    """Wrapper for the `deluge-console info` command.

    Returns:
        Return type is `str` when @ID is given and `List[str]` otherwise.
    """
    log.vdebug("ID = %s", ID)  # type: ignore

    cmd = (
        "{DELUGE} info --sort-reverse=time_added {ID} | "
        "awk -F: '{{if ($1==\"{field}\") print $0}}'".format(
            DELUGE=' '.join(DELUGE),
            field=field,
            ID=('' if ID is None else ID)
        )
    )
    out = gutils.shell(cmd)
    ret = out.split('\n')

    if ret[0] == '':
        raise ValueError(
            'Something went wrong with the `info` function. '
            'Local state:\n\n{}'.format(locals())
        )

    return ret if ID is None else ret[0]


def notify_and_log(msg):
    log.debug(msg)
    gutils.notify(msg)


if __name__ == "__main__":
    parser = gutils.ArgumentParser()
    parser.add_argument('magnet', help='The torrent magnet file.')

    default = '/media/bryan/zeus/media/Entertainment/Movies'
    parser.add_argument('-w', type=Path, dest='download_dir', default=default,
                        help='The directory that the torrents will be downloaded to. Defaults to {}.'.format(default))

    default = 0
    parser.add_argument('-D', type=int, dest='delay', default=default,
                        help='Delay starting the script for DELAY seconds. Defaults to {}.'.format(default))

    default = 0
    parser.add_argument('-t', type=float, dest='timeout', default=default,
                        help='Time (in hours) to attempt to complete download before timing out. If set to 0, this '
                             'script will run forever without ever timing out. Defaults to {}.'.format(default))

    default = 0
    parser.add_argument('--maxsize', type=int, dest='maxsize', default=default,
                        help='Max number of torrents allowed to download at one time (additional torrents will be '
                             'enqueued and start when a space opens up). Defaults to {}.'.format(default))

    default = 'nyc'
    parser.add_argument('--vpn', type=str, dest='vpn', default=default,
                        help='VPN to connect to. Defaults to {}.'.format(default))

    args = parser.parse_args()


    main(args)
