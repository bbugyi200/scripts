#!/usr/bin/env python

"""Filter and View Eternal Shell History Log"""

import datetime as dt
import os
import re
import subprocess as sp  # noqa: F401
import time

from dateutil.relativedelta import relativedelta
from dateutil.parser import parse

import gutils

#######################################################################################
#  gutils library: https://github.com/bbugyi200/scripts/tree/master/pymodules/gutils  #
#######################################################################################

log = gutils.logging.getEasyLogger(__name__)
scriptname = os.path.basename(os.path.realpath(__file__))


def main(args):
    fp_final = '/tmp/{0}/{0}.log'.format(scriptname)
    fp_final_dir = os.path.dirname(fp_final)
    if not os.path.exists(fp_final_dir):
        os.makedirs(fp_final_dir)

    logdir = '/home/bryan/Dropbox/var/logs/shell-history'

    build_custom_log(logdir, fp_final,
                     daterange=args.daterange,
                     username=args.username,
                     wdir=args.wdir,
                     hostname=args.hostname,
                     regexp=args.regexp)

    sp.check_call(['vim', '+', fp_final])


def build_custom_log(logdir, fp_final, *, daterange=None, username=None, wdir=None, hostname=None, regexp=None):
    """Construct the Contents of the Final Log File that the User Views"""
    dt_start, dt_end = get_daterange(args.daterange)
    hostname = os.uname().nodename if hostname is None else hostname
    regexp = '.*' if regexp is None else regexp

    with open(fp_final, 'w') as f:
        f.write('# vim: filetype=histlog\n\n')

    tmp_date = dt_start
    while tmp_date <= dt_end:
        fp_log = '{}/{}/{}/{:02}.log'.format(logdir, hostname, tmp_date.year, tmp_date.month)

        if hostname.upper() == 'ALL':
            fp_log = concat_logs(logdir, tmp_date.year, tmp_date.month)

        log_lines = process_logfile(fp_log,
                                    dt_end=dt_end,
                                    regexp=regexp,
                                    username=username,
                                    wdir=wdir)

        with open(fp_final, 'a+') as f:
            f.writelines(log_lines)

        tmp_date = tmp_date + relativedelta(months=1)


def concat_logs(logdir, year, month):
    """Concatenates Logfiles from All Hostnames

    Returns:
        str: Filepath for new (temporary) log file that should be processed.
    """
    all_hostnames = [d for d in os.listdir(logdir)
                     if os.path.isdir('{}/{}'.format(logdir, d))]
    all_log_files = ['{}/{}/{}/{:02}.log'.format(logdir, H, year, month)
                     for H in all_hostnames]
    fp_log = '/tmp/{}/{}.{}.log'.format(scriptname, year, month)
    cmd_fmt = 'cat {} | sort -t: -k 3n > {}'
    gutils.shell(cmd_fmt.format(' '.join(all_log_files), fp_log))

    # Protects against possible race condition
    for i in range(1, 3):
        if not os.path.exists(fp_log):
            time.sleep(i)
        else:
            break

    return fp_log


def process_logfile(fp, *, dt_end, regexp, username=None, wdir=None):
    """Process a single .log file.

    Returns:
        List of lines to append to final logfile that user will view.
    """
    matched_lines = []

    if not os.path.exists(fp):
        return []

    for line in open(fp, 'r'):
        try:
            hostname, user, date_string, wd, cmd = line.split(':', maxsplit=4)
        except ValueError as e:
            log.debug('line: %s', line.rstrip())
            log.debug("line.split(':'): %s", line.split(':'))
            raise e

        date = parse(date_string)

        conditions = [
            username is None or user == username,
            wdir is None or wd == wdir,
            date <= dt_end,
            re.match(regexp, cmd) is not None,
        ]

        if all(conditions):
            matched_lines.append(build_line(hostname, user, date, wd, cmd))

    return matched_lines


def build_line(hostname, user, date, wdir, cmd):
    """Construct a Log Line using the Final (prettified) Format"""
    pretty_line_fmt = '[{}] ({}@{}) {}\n\t{}\n'
    pretty_line = pretty_line_fmt.format(date.strftime('%Y-%m-%d %H:%M:%S'),
                                         user,
                                         hostname,
                                         wdir,
                                         cmd)

    return pretty_line


def get_daterange(daterange):
    """Get Daterange of Logs to View.

    Returns:
        tuple: (datetime, datetime)
    """
    if args.daterange is not None:
        dt_start = parse_date(daterange[0])
        dt_end = parse_date(daterange[1])
    else:
        dt_start = parse('20170101000000')
        dt_end = dt.datetime.now()

    return dt_start, dt_end


def parse_date(date):
    """Custom Date Parser."""
    D = date.lower()
    if D == 'today':
        return delta_today(0)

    if D == 'yesterday':
        return delta_today(-1)

    if D == 'now':
        return dt.datetime.now()

    return parse(D)


def delta_today(N):
    """Returns Datetime Relative to Today at 12AM"""
    today = dt.date.today()
    return dt.datetime.combine(today, dt.time.min) + dt.timedelta(days=N)


if __name__ == "__main__":
    parser = gutils.ArgumentParser()
    parser.add_argument('-D', '--daterange', nargs=2, metavar=('START', 'END'),
                        help='Filter logs by using a daterange.')
    parser.add_argument('-G', '--grep', dest='regexp', metavar='REGEXP',
                        help='Filter logs by command string using a regular expression.')
    parser.add_argument('-H', '--hostname', help="Filter logs by the machine's hostname.")
    parser.add_argument('-u', '--username', help='Filter logs by username.')
    parser.add_argument('-w', '--working-dir', dest='wdir', metavar='DIR',
                        help='Filter by what directory the user was in when the command was run.')
    args = parser.parse_args()

    with gutils.logging.context(log, debug=args.debug, verbose=args.verbose):
        main(args)
