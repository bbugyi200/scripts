#!/bin/bash

###################################################################################################
#  Create / Manage User Patches on Gentoo                                                         #
###################################################################################################

source /home/bryan/Dropbox/scripts/modules/bash/gutils.sh

# ensure running as root
if [ "$(id -u)" != "0" ]; then
  exec sudo "$0" -u "$USER" "$@"
fi

# ---------- Functions ----------
function check_patch_exists() {
    if ! [[ -f "$PATCH_PATH" || -f "$PATCH_NOVERSION_PATH" ]]; then
        die "$PATCH_NAME.patch does not exist."
    fi
}

function change_owner() {
    chown -R "$REGULAR_USER":"$REGULAR_USER" "$W"
}

# ---------- Global Variables ----------
USAGE="usage: $(basename "$0") [-h] [-d] [-a PATCH | -c | -I [PATCH] | [-V] -i PATCH | -l [PATCH] | -r PATCH | [-o OVERLAY] PACKAGE]"
W=/tmp/"$(basename "$0")"
OVERLAY="gentoo"
EPATCH_FILE="epatch.info"

read -r -d '' HELP << EOM
$USAGE

Steps to create an ebuild patch:

1) Run \`cd \$(epatch PACKAGE)\` (will cd to temp working directory).
2) Make your code changes.
3) Run \`epatch -i PATCH\` (while still in the temp working directory) to install PATCH.patch.
EOM

# ---------- Command-line Arguments ----------
eval set -- "$(getopt -o "a:,c,d,h,I,i:,l,o:,r:,V,u:" -l "apply:,clean,debug,help,install-pkg,install-patch:,list,overlay:,remove:,use-version-specifier,user:" -- "$@")"

while [[ -n "$1" ]]; do
    case $1 in
       -a|--apply )
           shift
           PATCH_NAME="$1"
           apply=true
           ;;
       -c|--clean )
           clean=true
           ;;
       -d|--debug )
           debug=true
           PS4='$LINENO: '
           set -x
           ;;
       -h|--help )
           echo "$HELP"
           exit 0
           ;;
       -I|--install-pkg )
           install_pkg=true
           ;;
       -i|--install-patch )
           shift
           PATCH_NAME="$1"
           install_patch=true
           ;;
       -l|--list )
           list=true
           ;;
       -o|--overlay )
           shift
           OVERLAY="$1"
           ;;
       -r|--remove )
           shift
           PATCH_NAME="$1"
           remove=true
           ;;
       -u|--user )
           shift
           REGULAR_USER="$1"
           ;;
       -V|--use-version-specifier )
           use_version_specifier=true
           ;;
       -- )
           shift
           break
           ;;
    esac
    shift
done

# ---------- Quick Action Handlers ----------
# if patch name is given with -I, install patch and package
if [[ "$install_pkg" = true && -n "$1" ]]; then
    install_patch=true
fi

if [[ "$apply" = true || "$clean" = true || "$install_pkg" = true || \
    "$install_patch" = true || "$list" = true || "$remove" = true ]] ; then
    quick_action=true
        
    if [[ -n "$1" ]]; then
        PATCH_NAME="$1"; shift
    fi

    if [[ -f "$(pwd)"/"$EPATCH_FILE" ]]; then
        PATCH_SUBDIR="$(head -n 1 "$EPATCH_FILE" )"
        W="$(pwd)"
    elif [[ "$(pwd)" =~ "$W"/[^/]*/.* ]]; then
        PATCH_SUBDIR="$(pwd | awk -F'/' '{printf "%s/%s", $4, $5}')"
    else
        die "Cannot use this option outside of $W/CATEGORY/PACKAGE"
    fi

    PATCH_DIR=/etc/portage/patches/"$PATCH_SUBDIR"
    PATCH_PATH="$PATCH_DIR"/"$PATCH_NAME".patch
    
    if [[ "$PATCH_DIR" =~ .*/[A-Za-z-]+-[0-9]+ ]]; then
        PATCH_NOVERSION_DIR="${PATCH_DIR%-*}"
    else
        PATCH_NOVERSION_DIR="$PATCH_DIR"
    fi
    
    PATCH_NOVERSION_PATH="$PATCH_NOVERSION_DIR"/"$PATCH_NAME".patch
fi


# >>> APPLY
if [[ "$apply" = true ]]; then
    check_patch_exists

    if [[ -f "$PATCH_PATH" ]]; then
        git apply "$PATCH_PATH"
        EC="$?"
    elif [[ -f "$PATCH_NOVERSION_PATH" ]]; then
        git apply "$PATCH_NOVERSION_PATH"
        EC="$?"
    fi

    [[ "$EC" -eq 0 ]] && emsg "Applied $PATCH_NAME.patch to git repository."
fi

# >>> CLEAN
if [[ "$clean" = true ]]; then
    git reset --hard HEAD &> /dev/null
    git clean -f &> /dev/null
    emsg "Restored git repository to initial state."
fi

# >>> INSTALL PATCH
if [[ "$install_patch" = true ]]; then
    if [[ "$use_version_specifier" ]]; then
        PDIR="$PATCH_DIR"
        PPATH="$PATCH_PATH"
    else
        PDIR="$PATCH_NOVERSION_DIR"
        PPATH="$PATCH_NOVERSION_PATH"
    fi

    EXISTING_PATCH_PATH="$(find "$PATCH_PATH" "$PATCH_NOVERSION_PATH" -name "*$PATCH_NAME.patch" 2> /dev/null | sort -u)"
    if [[ -n "$EXISTING_PATCH_PATH" && "$PPATH" != "$EXISTING_PATCH_PATH" ]]; then
        die "A patch with the same name cannot exist in a versioned patch directory and its\nnon-versioned counterpart.\n\nThe following patch must be removed before this one can be applied:\n$EXISTING_PATCH_PATH"
    fi

    [[ -d "$PDIR" ]] || mkdir -p "$PDIR"

    if [[ -f "$(pwd)"/"$EPATCH_FILE" ]]; then
        BRANCH="$(tail -n 1 "$EPATCH_FILE")"
    else
        BRANCH="HEAD"
    fi

    git add -A
    git diff --staged "$BRANCH" > "$PPATH"
    git reset HEAD &> /dev/null
    emsg "Installed patch to $PPATH."
fi

# >>> INSTALL PACKAGE
if [[ "$install_pkg" = true ]]; then
    get -f "${PATCH_NOVERSION_DIR##*/}"
fi

# >>> LIST
if [[ "$list" = true ]]; then
    if [[ -n "$PATCH_NAME" ]]; then
        check_patch_exists

        if [[ -f "$PATCH_PATH" ]]; then
            pygmentize -g "$PATCH_PATH"
        elif [[ -f "$PATCH_NOVERSION_PATH" ]]; then
            pygmentize -g "$PATCH_NOVERSION_PATH"
        fi
    else
        find "$PATCH_DIR" "$PATCH_NOVERSION_DIR" -name "*.patch" 2> /dev/null | sort -u
    fi
fi

# >>> REMOVE PATCH
if [[ "$remove" = true ]]; then
    check_patch_exists

    if [[ -f "$PATCH_PATH" ]]; then
        safe-rm "$PATCH_PATH"
        rmdir "$PATCH_DIR" &> /dev/null
        emsg "Removed $PATCH_PATH."
    fi

    if [[ -f "$PATCH_NOVERSION_PATH" ]]; then
        safe-rm "$PATCH_NOVERSION_PATH"
        rmdir "$PATCH_NOVERSION_DIR" &> /dev/null
        emsg "Removed $PATCH_NOVERSION_PATH."
    fi
fi

if [[ "$quick_action" = true ]]; then
    change_owner
    exit 0
fi

# ---------- Main ----------
if [[ -z "$1" ]]; then
    echo "$USAGE"
    exit 2
fi

PN="$1"; shift

OVERLAY_PATH="$(portageq get_repo_path / "$OVERLAY")"
EBUILD_CHOICES_RAW="$(find "$OVERLAY_PATH" -type f -regex ".*/$PN/.*\.ebuild" | tr '\n' ' ')"

if [[ -z "$EBUILD_CHOICES_RAW" ]]; then
    die "Unable to find the package $PN::$OVERLAY."
fi

IFS=' ' read -r -a EBUILD_CHOICES <<< "$EBUILD_CHOICES_RAW"

if [[ "${#EBUILD_CHOICES[@]}" -eq 1 ]]; then
    EBUILD="${EBUILD_CHOICES[0]}"
else
    PS3=$'\n'"Select an ebuild to patch: "
    select EBUILD in "${EBUILD_CHOICES[@]}"; do
        case "$EBUILD" in
            * )
                break
                ;;
        esac
    done
fi

P="$(basename "${EBUILD%.ebuild}")"

# Removes revision number from ${P}
if [[ "$P" =~ .*-r[0-9]+ ]]; then
    P="${P%-r*}"
fi

# Disables STDOUT and STDERR
if [[ "$debug" != true ]]; then
    exec 5>&1 > /dev/null
    exec 2>&1
fi

ebuild "$EBUILD" clean unpack

PORTAGE_BUILD_DIR=/var/tmp/portage
WORK_DIR="$(find "$PORTAGE_BUILD_DIR" -type d -regex ".*/work/${P%_*}[^/]*")"

CATEGORY="$(echo "${WORK_DIR#$PORTAGE_BUILD_DIR}" | awk -F'/' '{print $2}')"

TMP_WORK_DIR="$W"/"$CATEGORY"
TMP_WORK_DIR="$TMP_WORK_DIR"/"$P"

[[ -d "$TMP_WORK_DIR" ]] || mkdir -p "$TMP_WORK_DIR"
cp -r "$WORK_DIR"/* "$TMP_WORK_DIR"

cd "$TMP_WORK_DIR" || exit 1
git init
git add .
git commit -m "Initial Commit"

change_owner

if [[ "$debug" != true ]]; then
    exec 1>&5  # Restores STDOUT
fi
printf "$TMP_WORK_DIR"
