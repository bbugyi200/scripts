#!/bin/bash

# My Colors
GREEN="#0BF816"
YELLOW="#EBEE27"
RED="#FB0611"
BLUE="#3C4BF7"
WHITE="#FFFFFF"
GREY="#D9D9D9"


RUNTIME_DIR=$XDG_RUNTIME_DIR/$(basename $0)
DATA_DIR=/home/$USER/.local/share/$(basename $0)
PID_FILE=$RUNTIME_DIR/pid
TIMESTAMP_FILE=$DATA_DIR/timestamp
FIFO=$RUNTIME_DIR/fifo

[[ -d $RUNTIME_DIR ]] || mkdir $RUNTIME_DIR
[[ -d $DATA_DIR ]] || mkdir $DATA_DIR

time_left() {
	echo $(($stop_time - $(date --date="now" +%s)))
}

exit_handler() {
    printf "\n" > "$FIFO"
    rm $TIMESTAMP_FILE
}


# ---------- Command Line Arguments ----------
eval set -- "$(getopt -o "d,r,s,T" -l "debug,resume,stop,tomorrow" -- "$@")"

while [[ -n "$1" ]]; do
	case $1 in
        -d|--debug )
            PS4='$LINENO: '
            set -x;;
        -r|--resume )
            resume=true;;
        -s|--stop )
            stop=true;;
        -T|--tomorrow )
            tomorrow=true;;
		-- )
			shift
			break;;
	esac
	shift
done


if [[ "$resume" = true && ! -f $TIMESTAMP_FILE ]]; then
    exit 1
fi

if [[ "$stop" = true ]]; then
    exec 1> /dev/null
fi

[[ -p $FIFO ]] || mkfifo $FIFO


# ---------- Another Alarm is Already Running ----------
if [[ -f $PID_FILE ]]; then
    if kill -0 "$(cat $PID_FILE)" &> /dev/null; then
        if [[ "$resume" = true ]]; then
            echo "No need to restart! An alarm is already running!" | tee >(logger -t "$(basename $0)")
            exit 2
        fi

        echo "An alarm is already running! Stopping existing alarm!" | tee >(logger -t "$(basename $0)")

        cat $PID_FILE | xargs kill

        rm $TIMESTAMP_FILE
        if pgrep dunst; then
            sleep 0.5
            xdotool key ctrl+space  # Shortcut to close dunst notification
        fi
        exit 0
    fi
fi

if [[ "$stop" = true ]]; then
    printf "\n" > "$FIFO"
    exit 1
fi

echo $$ > $PID_FILE
trap ':' SIGPIPE
trap 'exit_handler; exit 1' SIGINT


# ---------- Set Alarm Time ----------
if [[ -f $TIMESTAMP_FILE ]]; then
    stop_time=$(cat $TIMESTAMP_FILE)
else
    if [[ -z "$1" ]]; then
        alrm_time="$(echo | dmenu -p "Alarm:")"
    else
        alrm_time=$1; shift
    fi

    if [[ -z "$alrm_time" ]]; then
        exit 1
    fi


    if [[ $alrm_time == *"s" ]]; then
        stop_time=$(date --date="${alrm_time%s} seconds" +%s)
    elif [[ $alrm_time == *":"* ]]; then
        stop_time=$(date --date="$alrm_time" +%s)
        if [[ $(date +%s) -ge $stop_time ]] || [[ "$tomorrow" = true ]]; then
            stop_time=$(date --date="$alrm_time tomorrow" +%s)
        fi
    else
        stop_time=$(date --date="$alrm_time minutes" +%s)
    fi

    echo $stop_time > $TIMESTAMP_FILE
fi

# ---------- Set Notification Message ----------
if [[ -z "$1" ]]; then
    NOTIFICATION="THE TIMER IS DONE!"
else
    NOTIFICATION="$1"; shift
fi


# ---------- Main Output ----------
iclock="<icon=clock.xbm/>"
while true; do
	TL=$(time_left)
	if [[ $TL -ge 3600 ]]; then
		printf "<fc=$GREY>  %d:%02d:%02d$iclock</fc>  |  \n" $((TL/3600)) $((TL%3600/60)) $((TL%3600%60))
	else
		printf "<fc=$GREY>  %d:%02d$iclock</fc>  |  \n" $((TL/60)) $((TL%60))
	fi
	sleep 1

	if [[ $TL -le 0 ]]; then
		break;
	fi
done > "$FIFO"


# ---------- Timer Finished ----------
notify-send -u critical -t 0 -i /usr/share/icons/gnome/16x16/status/appointment-soon.png "Alarm" "$NOTIFICATION"
exit_handler
