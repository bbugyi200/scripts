#!/usr/bin/env python

"""Interface for Gentoo System Maintenance Tasks"""

import datetime as dt
import os
import subprocess as sp  # noqa: F401
import sys

import gutils

############################################################################################
#  gutils library: https://github.com/bbugyi200/pylibs/tree/master/gutils                  #
############################################################################################

log = gutils.logging.getEasyLogger(__name__)
scriptname = os.path.basename(os.path.realpath(__file__))
ts_fmt = '%Y%m%d%H%M%S'


def main(args):
    cmd_list = []
    if args.update:
        cmd = 'eupdate'
    elif args.cleanup:
        cmd = 'ecleanup'
    elif args.maint_check:
        cmd = 'emaint_check'

    cmd_list.append(cmd)
    data_dir = gutils.xdg.init('data')
    local_hostname = os.uname().nodename

    cmd_dir = '/{}/{}/{}'.format(data_dir, local_hostname, cmd)
    local_tsfile = '{}/timestamp'.format(cmd_dir)

    if args.pretend:
        print(cmd)
        sys.exit(0)
    elif args.dsl:
        if args.dsl == 'local':
            days = days_since_last(local_tsfile)
            print(days)
        elif args.dsl == 'remote':
            remote_hostnames = [H for H in os.listdir(data_dir) if H != local_hostname]
            remote_ts_files = ['{}/{}/{}/timestamp'.format(data_dir, H, cmd)
                               for H in remote_hostnames]

            for H, fp in zip(remote_hostnames, remote_ts_files):
                days = days_since_last(fp)
                print('{}:{}'.format(H, days))

        sys.exit(0)

    # Just used to force myself to use emanage. :)
    # Requires that the secret.sh file be sourced into every script that could be called here.
    secret = gutils.secret()
    cmd_list.extend([secret])

    fp_count = '{}/count'.format(cmd_dir)
    if os.path.exists(fp_count):
        with open(fp_count, 'r') as f:
            count = f.read().strip()

        if int(count) > 0:
            choice = gutils.getch('>>> Would you like to resume `{}` where you left off (y), redo the last command (r),\n start a new session (n)?: '.format(cmd))

            if choice == 'y':
                cmd_list.append(count)
            elif choice == 'r':
                cmd_list.append(str(int(count) - 1))
            elif choice != 'n':
                sys.exit(0)

    try:
        sp.check_call(cmd_list)
    except KeyboardInterrupt as e:
        print()
        gutils.imsg('SIGINT signal detected. Terminating...')
        sys.exit(130)

    write_timestamp(local_tsfile, cmd)


def days_since_last(fp_timestamp):
    try:
        date_string = open(fp_timestamp, 'r').read().rstrip()
        last_clean = dt.datetime.strptime(date_string, ts_fmt)
        delta = dt.datetime.today() - last_clean
        days = delta.days
    except FileNotFoundError:
        days = 99999

    return days


def write_timestamp(fp, cmd):
    """Writes Timestamp to a File"""
    dp = os.path.dirname(fp)
    if not os.path.exists(dp):
        os.makedirs(dp)

    with open(fp, 'w') as f:
        now = dt.datetime.now()
        f.write(now.strftime(ts_fmt))


if __name__ == "__main__":
    parser = gutils.ArgumentParser()
    ex_group = parser.add_mutually_exclusive_group()
    ex_group.add_argument('-u', '--update', dest='update', action='store_true',
                         help='Update the machine.')
    ex_group.add_argument('-c', '--cleanup', dest='cleanup', action='store_true',
                         help='Run cleanup tasks.')
    ex_group.add_argument('-m', '--maint-check', dest='maint_check', action='store_true',
                         help='Check if any maintenance is due.')
    ex_group2 = parser.add_mutually_exclusive_group()
    ex_group2.add_argument('-D', '--days-since-last', dest='dsl', choices=['local', 'remote'],
                        help='Prints the number of days its been since the specified maintenance '
                             'task was last performed. This option takes an argument indicating '
                             'what machine(s) to check. "local" indicates the local machine and '
                             '"remote" indicates all remote machines.')
    ex_group2.add_argument('-P', '--pretend', dest='pretend', action='store_true',
                        help='Prints the command list instead of executing it.')
    args = parser.parse_args()

    with gutils.logging.context(log, debug=args.debug, verbose=args.verbose):
        main(args)
