#!/bin/bash

###################################################################################################
#  epatch                                                                                         #
#                                                                                                 #
# This script aids in the creation and maintainance of  user patches on Gentoo.                   #
###################################################################################################

source /usr/lib/gutils.sh

# ensure running as root
if [ "$(id -u)" != "0" ]; then
  exec sudo "$0" -u "${USER}" "$@"
fi

# ---------- Functions ----------
function check_path_exists() {
    if ! [[ -f "${PATCH_PATH}" || -f "${PATCH_NOVERSION_PATH}"
         || -f "${STASH_PATH}" || -f "${STASH_NOVERSION_PATH}" ]]; then
        die "${PN} patch/stash does not exist."
    fi
}

function change_owner() {
    chown -R "${REGULAR_USER}":"${REGULAR_USER}" "${W}"
}

function patch_install() {
    if [[ "${use_version_specifier}" ]]; then
        PDIR="${PATCH_DIR}"
        PPATH="${PATCH_PATH}"
    else
        PDIR="${PATCH_NOVERSION_DIR}"
        PPATH="${PATCH_NOVERSION_PATH}"
    fi

    EXISTING_PATCH_PATH="$(find "${PATCH_PATH}" "${PATCH_NOVERSION_PATH}" -name "*${PN}.patch" 2> /dev/null | sort -u)"
    if [[ -n "${EXISTING_PATCH_PATH}" && "${PPATH}" != "${EXISTING_PATCH_PATH}" ]]; then
        die "A patch with the same name cannot exist in a versioned patch directory and its\nnon-versioned counterpart.\n\nThe following patch must be removed before this one can be applied:\n${EXISTING_PATCH_PATH}"
    fi

    [[ -d "${PDIR}" ]] || mkdir -p "${PDIR}"

    if [[ -f "$(pwd)"/"${EPATCH_FILE}" ]]; then
        BRANCH="$(tail -n 1 "${EPATCH_FILE}")"
    else
        BRANCH="HEAD"
    fi

    git add -A
    git diff --staged "${BRANCH}" > "${PPATH}"
    git reset HEAD &> /dev/null
    imsg "Installed patch to ${PPATH}."
}

function make_real_paths() {
    if [[ -f "${PATCH_PATH}" ]]; then
        REAL_PATH="${PATCH_PATH}"
        REAL_DIR="${PATCH_DIR}"
        REAL_PATCH_PATH="${PATCH_PATH}"
        REAL_STASH_PATH="${STASH_PATH}"
    elif [[ -f "${PATCH_NOVERSION_PATH}" ]]; then
        REAL_PATH="${PATCH_NOVERSION_PATH}"
        REAL_DIR="${PATCH_NOVERSION_DIR}"
        REAL_PATCH_PATH="${PATCH_NOVERSION_PATH}"
        REAL_STASH_PATH="${STASH_NOVERSION_PATH}"
    elif [[ -f "${STASH_PATH}" ]]; then
        REAL_PATH="${STASH_PATH}"
        REAL_DIR="${PATCH_DIR}"
        REAL_PATCH_PATH="${PATCH_PATH}"
        REAL_STASH_PATH="${STASH_PATH}"
    elif [[ -f "${STASH_NOVERSION_PATH}" ]]; then
        REAL_PATH="${STASH_NOVERSION_PATH}"
        REAL_DIR="${PATCH_NOVERSION_DIR}"
        REAL_PATCH_PATH="${PATCH_NOVERSION_PATH}"
        REAL_STASH_PATH="${STASH_NOVERSION_PATH}"
    fi
}

# ---------- Global Variables ----------
USAGE="usage: $(basename "$0") [-h] [-d] [-a PATCH | -c | -I [PATCH] | [-V] -i PATCH | -l [PATCH] | -r PATCH | -s PATCH | [-o OVERLAY] PACKAGE]"
W=/tmp/"$(basename "$0")"
OVERLAY="gentoo"
EPATCH_FILE="epatch.info"

read -r -d '' HELP << EOM
${USAGE}

Steps to create an ebuild patch:

1) Run \`cd \$(epatch PACKAGE)\` (will cd to temp working directory).
2) Make your code changes.
3) Run \`epatch -i PATCH\` (while still in the temp working directory) to install PATCH.patch.
EOM

# ---------- Command-line Arguments ----------
eval set -- "$(getopt -o "a:,c,d,h,I,i:,l,o:,r:,s:,V,u:" -l "apply:,clean,debug,help,install-pkg,install-patch:,list,overlay:,remove:,stash:,use-version-specifier,user:" -- "$@")"

while [[ -n "$1" ]]; do
    case $1 in
       -a|--apply )
           shift
           PN="$1"
           apply=true
           ;;
       -c|--clean )
           clean=true
           ;;
       -d|--debug )
           debug=true
           PS4='$LINENO: '
           set -x
           ;;
       -h|--help )
           echo "${HELP}"
           exit 0
           ;;
       -I|--install-pkg )
           install_pkg=true
           ;;
       -i|--install-patch )
           shift
           PN="$1"
           install_patch=true
           ;;
       -l|--list )
           list=true
           ;;
       -o|--overlay )
           shift
           OVERLAY="$1"
           ;;
       -r|--remove )
           shift
           PN="$1"
           remove=true
           ;;
       -s|--stash )
           shift
           PN="$1"
           stash=true
           ;;
       -u|--user )
           shift
           REGULAR_USER="$1"
           ;;
       -V|--use-version-specifier )
           use_version_specifier=true
           ;;
       -- )
           shift
           break
           ;;
    esac
    shift
done

# ---------- Quick Action Handlers ----------
if [[ "${apply}" = true || "${clean}" = true || "${install_pkg}" = true
   || "${install_patch}" = true || "${list}" = true || "${remove}" = true
   || "${stash}" = true ]]; then
    quick_action=true
        
    if [[ -n "$1" ]]; then
        PN="$1"; shift
    fi

    if [[ -f "$(pwd)"/"${EPATCH_FILE}" ]]; then
        PATCH_SUBDIR="$(head -n 1 "${EPATCH_FILE}" )"
        W="$(pwd)"
    elif [[ "$(pwd)" =~ "${W}"/[^/]*/.* ]]; then
        PATCH_SUBDIR="$(pwd | awk -F'/' '{printf "%s/%s", $4, $5}')"
    else
        die "Cannot use this option outside of ${W}/CATEGORY/PACKAGE"
    fi

    PATCH_DIR=/etc/portage/patches/"${PATCH_SUBDIR}"
    PATCH_PATH="${PATCH_DIR}"/"${PN}".patch
    STASH_PATH="${PATCH_PATH%.patch}.stash"
    
    if [[ "${PATCH_DIR}" =~ .*/[A-Za-z-]+-[0-9]+ ]]; then
        PATCH_NOVERSION_DIR="${PATCH_DIR%-*}"
    else
        PATCH_NOVERSION_DIR="${PATCH_DIR}"
    fi
    
    PATCH_NOVERSION_PATH="${PATCH_NOVERSION_DIR}"/"${PN}".patch
    STASH_NOVERSION_PATH="${PATCH_NOVERSION_PATH%.patch}.stash"
fi


# >>> APPLY
if [[ "${apply}" = true ]]; then
    check_path_exists
    make_real_paths

    FILENAME="$(basename "${REAL_PATH}")"
    if ! git apply "${REAL_PATH}" &> /dev/null; then
        imsg "Failed to apply ${FILENAME} to git repository."
        git apply -v "${REAL_PATH}"
    else
        imsg "Applied ${FILENAME} to git repository."
    fi
fi

# >>> CLEAN
if [[ "${clean}" = true ]]; then
    git reset --hard HEAD &> /dev/null
    git clean -f &> /dev/null
    imsg "Restored git repository to initial state."
fi

# >>> INSTALL PATCH
if [[ "${install_patch}" = true ]]; then
    patch_install
fi

# >>> INSTALL PACKAGE
if [[ "${install_pkg}" = true ]]; then
    if [[ -n "${PN}" ]]; then
        patch_install
    fi
    get -f "${PATCH_NOVERSION_DIR##*/}"
fi

# >>> LIST
if [[ "${list}" = true ]]; then
    if [[ -n "${PN}" ]]; then
        check_path_exists
        make_real_paths

        pygmentize -g "${REAL_PATH}"
    else
        find "${PATCH_DIR}" "${PATCH_NOVERSION_DIR}" -name "*.patch" -o -name "*.stash" 2> /dev/null | sort -u
    fi
fi

# >>> REMOVE
if [[ "${remove}" = true ]]; then
    check_path_exists
    make_real_paths

    safe-rm "${REAL_PATH}"
    rmdir "${REAL_DIR}" &> /dev/null
    imsg "Removed ${REAL_PATH}."
fi

# >>> STASH
if [[ "${stash}" = true ]]; then
    check_path_exists
    make_real_paths

    if [[ -f "${PATCH_PATH}" || -f "${PATCH_NOVERSION_PATH}" ]]; then
        action="Stashed"
        src="${REAL_PATCH_PATH}"
        dest="${REAL_STASH_PATH}"
    elif [[ -f "${STASH_PATH}" || -f "${STASH_NOVERSION_PATH}" ]]; then
        action="Unstashed"
        src="${REAL_STASH_PATH}"
        dest="${REAL_PATCH_PATH}"
    fi

    mv "${src}" "${dest}"
    imsg "${action} ${PN}."
fi

if [[ "${quick_action}" = true ]]; then
    change_owner
    exit 0
fi

# ---------- Main ----------
if [[ -z "$1" ]]; then
    echo "${USAGE}"
    exit 2
fi

PN="$1"; shift

OVERLAY_PATH="$(portageq get_repo_path / "${OVERLAY}")"
EBUILD_CHOICES_RAW="$(find "${OVERLAY_PATH}" -type f -regex ".*/${PN}/.*\.ebuild" | tr '\n' ' ')"

if [[ -z "${EBUILD_CHOICES_RAW}" ]]; then
    die "Unable to find the package ${PN}::${OVERLAY}."
fi

IFS=' ' read -r -a EBUILD_CHOICES <<< "${EBUILD_CHOICES_RAW}"

if [[ "${#EBUILD_CHOICES[@]}" -eq 1 ]]; then
    EBUILD="${EBUILD_CHOICES[0]}"
else
    PS3=$'\n'"Select an ebuild to patch: "
    select EBUILD in "${EBUILD_CHOICES[@]}"; do
        case "${EBUILD}" in
            * )
                break
                ;;
        esac
    done
fi

P="$(basename "${EBUILD%.ebuild}")"

# Removes revision number from ${P}
if [[ "${P}" =~ .*-r[0-9]+ ]]; then
    P="${P%-r*}"
fi

# Disables STDOUT and STDERR
if [[ "${debug}" != true ]]; then
    exec 5>&1 > /dev/null
    exec 2>&1
fi

ebuild "${EBUILD}" clean unpack

PORTAGE_BUILD_DIR=/var/tmp/portage
WORK_DIR="$(find "${PORTAGE_BUILD_DIR}" -type d -regex ".*/work/${P%_*}[^/]*")"

CATEGORY="$(echo "${WORK_DIR#${PORTAGE_BUILD_DIR}}" | awk -F'/' '{print $2}')"

TMP_WORK_DIR="${W}"/"${CATEGORY}"
TMP_WORK_DIR="${TMP_WORK_DIR}"/"${P}"

[[ -d "${TMP_WORK_DIR}" ]] || mkdir -p "${TMP_WORK_DIR}"
cp -r "${WORK_DIR}"/* "${TMP_WORK_DIR}"
cp /home/bryan/Dropbox/var/templates/localalias.epatch "${TMP_WORK_DIR}"/.localalias

cd "${TMP_WORK_DIR}" || exit 1
git init
git add .
git commit -m "Initial Commit"

change_owner

if [[ "${debug}" != true ]]; then
    exec 1>&5  # Restores STDOUT
fi
printf "${TMP_WORK_DIR}"
