#!/usr/bin/env python

""" Stops Current TaskWarrior Task if Machine Idles for Too Long
and Restarts the Task when Activity Resumes """

import argparse
import logging
import os
import time
import subprocess as sp
import sys

from systemd.journal import JournalHandler

log = logging.getLogger(__name__)

max_help = 'max amount of idletime (in minutes) to allow before stopping task'
delay_help = 'time (in seconds) to delay between calls to xprintidle'
waittime_help = 'time (in minutes) to wait for activity after stopping task'

PIDFILE = "/tmp/{}.pid".format(os.path.basename(__file__))
MILLISECONDS_IN_MINUTE = 60000
DEVNULL = open(os.devnull, 'w')


def create_pidfile():
    """ Writes PID to File """
    if os.path.isfile(PIDFILE):
        old_pid = open(PIDFILE, 'r').read()
        try:
            os.kill(int(old_pid), 0)
        except OSError as e:
            pass
        except ValueError as e:
            if old_pid != '':
                raise
        else:
            msg = 'Another instance of {} is already running.'
            raise RuntimeError(msg.format(os.path.basename(__file__)))
    pid = os.getpid()
    open(PIDFILE, 'w').write(str(pid))


def xprintidle():
    """ Returns Machine's Current Idletime """
    out = sp.check_output(['xprintidle'])
    return int(out.decode())


def check_call(*args):
    """ Wrapper for subprocess.check_call """
    sp.check_call(args, stdout=DEVNULL, stderr=DEVNULL)


def main():
    log.info('Starting...')

    MAX_IDLE = args.idletime * MILLISECONDS_IN_MINUTE
    MAX_WAIT = args.waittime * MILLISECONDS_IN_MINUTE

    while True:
        if xprintidle() >= MAX_IDLE:
            try:
                log.info('Stopping current task...')
                check_call('task', 'start.any:', 'stop')
            except sp.CalledProcessError as e:
                raise RuntimeError('Failed to stop task. No task is currently started.')
        else:
            time.sleep(args.delay)
            continue

        while True:
            time.sleep(1)
            idletime = xprintidle()
            if idletime <= MAX_IDLE:
                log.info('Restarting last task...')
                check_call('last_task')
                check_call('notify-send', sys.argv[0], 'The last active TaskWarrior task has been restarted.')
                break
            elif idletime >= MAX_WAIT:
                log.info('Timed out. Terminating...')
                sys.exit(0)


def start_logging(log):
    """ Initializes Log Handlers """
    sh = logging.StreamHandler()
    jh = JournalHandler()
    fh = logging.FileHandler('/var/tmp/{}.log'.format(os.path.basename(__file__)))

    basic_formatting = '[%(levelname)s] %(message)s'
    formatter = logging.Formatter(basic_formatting)
    sh.setFormatter(formatter)
    jh.setFormatter(formatter)
    fh.setFormatter(logging.Formatter('(%(asctime)s) {}'.format(basic_formatting),
                                      datefmt='%Y-%m-%d %H:%M:%S'))

    sh.setLevel(logging.ERROR)
    jh.setLevel(logging.INFO)
    fh.setLevel(logging.DEBUG)
    log.setLevel(logging.DEBUG)

    log.addHandler(sh)
    log.addHandler(jh)
    log.addHandler(fh)


if __name__ == "__main__":
    start_logging(log)

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-i', dest='idletime', nargs='?', type=float, default=5, help=max_help)
    parser.add_argument('-d', '--debug', action='store_true', help='enable debugging mode')
    parser.add_argument('-D', dest='delay', nargs='?', type=int, default=30, help=delay_help)
    parser.add_argument('-w', dest='waittime', nargs='?', type=float, default=30, help=waittime_help)
    args = parser.parse_args()

    if args.debug:
        for handler in log.handlers:
            handler.setLevel(logging.DEBUG)

    try:
        assert (args.waittime > args.idletime), "Max wait time must be greater than max idletime."
        create_pidfile()
        main()
    except AssertionError as e:
        log.error(str(e))
        print('\n')
        parser.print_help()
        sys.exit(1)
    except RuntimeError as e:
        log.error(str(e))
        sys.exit(2)
    except Exception as e:
        log.error('{}: {}'.format(type(e).__name__, str(e)))
        raise
