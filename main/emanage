#!/usr/bin/python3

"""Interface for Gentoo System Maintenance Tasks"""

import datetime as dt
import os
import subprocess as sp  # noqa: F401
import sys

import gutils

############################################################################################
#  gutils library: https://github.com/bbugyi200/pylibs/tree/master/gutils                  #
############################################################################################

log = gutils.logging.getEasyLogger(__name__)
SCRIPTNAME = os.path.basename(os.path.realpath(__file__))
ts_fmt = '%Y%m%d%H%M%S'


def main(args):
    cmd_list = []
    cmd_opts = []

    log.vdebug('args => %s', repr(args))

    if args.update:
        cmd = 'eupdate'
    elif args.cleanup:
        cmd = 'ecleanup'
    elif args.maint_check:
        cmd = 'emaint_check'
        cmd_opts.append(str(args.max_days))
    else:
        raise RuntimeError('No maintenance task specified.')

    cmd_list.append(cmd)
    cmd_list.extend(cmd_opts)

    data_dir = gutils.xdg.init('data')
    local_hostname = os.uname().nodename

    cmd_dir = '/{}/{}/{}'.format(data_dir, local_hostname, cmd)
    local_tsfile = '{}/timestamp'.format(cmd_dir)

    if args.pretend:
        print(cmd)
        sys.exit(0)
    elif args.dsl:
        if args.dsl == 'local':
            days = days_since_last(local_tsfile)
            print(days)
        elif args.dsl == 'remote':
            remote_hostnames = [H for H in os.listdir(data_dir) if H != local_hostname]
            remote_ts_files = ['{}/{}/{}/timestamp'.format(data_dir, H, cmd)
                               for H in remote_hostnames]

            for H, fp in zip(remote_hostnames, remote_ts_files):
                days = days_since_last(fp)
                print('{}:{}'.format(H, days))

        sys.exit(0)

    # Just used to force myself to use emanage. :)
    # Requires that the secret.sh file be sourced into every script that could be called here.
    secret = gutils.secret()
    cmd_list.extend([secret])

    fp_count = '{}/count'.format(cmd_dir)
    if os.path.exists(fp_count):
        with open(fp_count, 'r') as f:
            count = f.read().strip()

        if int(count) > 0:
            import textwrap

            prompt = '>>> Would you like to resume `{}` where you left off (y), redo the last command (r), or start a new session (n)?: '.format(cmd)
            choice = gutils.io.getch('\n'.join(textwrap.wrap(prompt, 80)))

            if choice == 'y':
                cmd_list.append(count)
            elif choice == 'r':
                cmd_list.append(str(int(count) - 1))
            elif choice != 'n':
                sys.exit(0)

    try:
        sp.check_call(cmd_list)
    except KeyboardInterrupt:
        print()
        gutils.io.imsg('SIGINT signal detected. Terminating...')
        sys.exit(130)
    except sp.CalledProcessError:
        # The 'confirm' script will exit with return code of 1 if key other
        # than 'y' or 'n' (like 'x') is pressed.
        pass
    else:
        write_timestamp(local_tsfile, cmd)


def days_since_last(fp_timestamp):
    try:
        date_string = open(fp_timestamp, 'r').read().rstrip()
        last_clean = dt.datetime.strptime(date_string, ts_fmt)
        delta = dt.datetime.today() - last_clean
        days = delta.days
    except FileNotFoundError:
        days = 99999

    return days


def write_timestamp(fp, cmd):
    """Writes Timestamp to a File"""
    dp = os.path.dirname(fp)
    if not os.path.exists(dp):
        os.makedirs(dp)

    with open(fp, 'w') as f:
        now = dt.datetime.now()
        f.write(now.strftime(ts_fmt))


if __name__ == "__main__":
    parser = gutils.ArgumentParser()

    parser.add_argument('-M', '--max-days', nargs='?', type=int,
                        help="Max number of days without update before complaining. This option "
                             "is only checked when used with the '--maint-check' option.")

    ex_group = parser.add_mutually_exclusive_group()
    ex_group.add_argument('-u', '--update', dest='update', action='store_true',
                         help='Update the machine.')
    ex_group.add_argument('-c', '--cleanup', dest='cleanup', action='store_true',
                         help='Run cleanup tasks.')
    ex_group.add_argument('-m', '--maint-check', action='store_true',
                         help='Check if any maintenance is due.')
    ex_group2 = parser.add_mutually_exclusive_group()
    ex_group2.add_argument('-D', '--days-since-last', dest='dsl', choices=['local', 'remote'],
                        help='Prints the number of days its been since the specified maintenance '
                             'task was last performed. This option takes an argument indicating '
                             'what machine(s) to check. "local" indicates the local machine and '
                             '"remote" indicates all remote machines.')
    ex_group2.add_argument('-P', '--pretend', dest='pretend', action='store_true',
                        help='Prints the command list instead of executing it.')

    args = parser.parse_args()

    if args.maint_check and args.max_days is None:
        parser.error(
            'The --max-days option must be provided when --maint-check '
            'is specified.'
        )

    with gutils.logging.context(log, debug=args.debug, verbose=args.verbose):
        main(args)
