#!/usr/bin/env python3

""" Script to make torrenting movies and TV shows easier (uses transmission as a backend).

Connects to a VPN (using Private Internet Access), downloads the torrent (using a magnet file),
disconnects from the VPN when the download is finished, and then sends me a text message to let
me know the download is complete.

Multiple torrents can be downloaded at the same time by simply running this script multiple times
(using different magnet files). If another instance of this script is running, the primary instance
will be signaled to enqueue the new magnet file for download.
"""

import atexit
import contextlib
import os
import pickle
import threading
import time
import signal
import re
import subprocess as sp
import sys
import queue

import gutils

#######################################################################################
#  gutils library: https://github.com/bbugyi200/scripts/tree/master/pymodules/gutils  #
#######################################################################################


class MagnetCounter:
    """ Thread-Safe Counter of Magnet Files """
    def __init__(self):
        self.lock = threading.Lock()
        self.count = 0

    def increment(self):
        with self.lock:
            self.count += 1
            return self.count


SECONDS_IN_HOUR = 3600
MAGNET_FILE = '{}/magnet'.format(gutils.xdg.getdir('data'))

log = gutils.logging.getEasyLogger(__name__)
magnet_counter = MagnetCounter()
magnet_queue = queue.Queue()
threads = []


def torrent(magnet):
    """ Creates new torrent thread worker. """
    t = threading.Thread(target=_torrent, args=(magnet,), daemon=True)
    t.start()
    threads.append(t)


def _torrent(magnet):
    """ Thread worker

    Downloads the torrent given by the @magnet string.
    """
    log.debug('Adding "{}" to Magnet Queue...'.format(magnet_pprint(magnet)))
    magnet_queue.put(magnet)

    magnet_id = magnet_counter.increment()

    with gutils.logging.context(log), runtime_context():
        try:
            i = 0
            while True:
                time.sleep(1)
                try:
                    sp.check_call(['transmission-remote', '-a', magnet], stdout=sp.DEVNULL)
                except sp.CalledProcessError:
                    i += 1
                    if i <= 10:
                        continue
                    else:
                        raise RuntimeError('Failed to start "{}".'.format(magnet_pprint(magnet)))
                else:
                    log.debug('Successfully added "{}".'.format(magnet_pprint(magnet)))
                    break

            i = 0
            while True:
                SLEEP_TIME = 5

                i += 1
                if i > (args.timeout * SECONDS_IN_HOUR / SLEEP_TIME):
                    msg = "Torrent is still attempting to download \"{0}\" after {1:.1f} hour(s) "\
                          " elapsed time. Shutting down early.".format(magnet_pprint(magnet), args.timeout)
                    raise RuntimeError(msg)

                time.sleep(SLEEP_TIME)

                ps = sp.Popen(['transmission-remote', '-l'], stdout=sp.PIPE)
                out = ps.communicate()[0].decode()
                out_lines = [line.strip() for line in out.split('\n')]

                status_line = None
                for line in out_lines:
                    if re.match(r'^{}\s.*'.format(magnet_id), line):
                        status_line = line.lower()
                        break

                if status_line is None:
                    msg = 'The magnet "{}" has been lost somehow. The download was perhaps '\
                          'stopped manually?'.format(magnet_pprint(magnet))
                    raise RuntimeError(msg)

                if '100%' in status_line:
                    break

            gutils.notify('Finished Downloading "{}".'.format(magnet_pprint(magnet)))

        finally:
            remove_magnet(magnet_id)
            magnet_queue.get()
            magnet_queue.task_done()


@contextlib.contextmanager
def runtime_context():
    """ RuntimeError Context Manager

    Context manager that makes sure users are notified of runtime exceptions.
    """
    try:
        yield
    except RuntimeError as e:
        notify(str(e))
        raise


def notify(msg):
    """ Sends Desktop Notification and (possibly) SMS Notification """
    log.debug('Sending notification to user.'.format(msg))
    gutils.notify('-t', '0', msg)
    if args.textme:
        sp.check_call(['textme', msg])


def remove_magnet(magnet_id):
    """ Removes Transmission Magnet File """
    try:
        sp.check_call(['transmission-remote', '-t{}'.format(magnet_id), '-r'], stdout=sp.DEVNULL)
        log.debug('Successfully removed magnet #{}.'.format(magnet_id))
    except sp.CalledProcessError:
        log.debug('Attempted to remove magnet #{} but it is NOT active.'.format(magnet_id))


def create_pidfile():
    """ Duplicate Process Management """
    try:
        gutils.create_pidfile()
    except gutils.StillAliveException as e:
        log.debug('Dumping "{}" to {}.'.format(magnet_pprint(args.magnet), MAGNET_FILE))
        with open(MAGNET_FILE, 'wb') as f:
            pickle.dump(args.magnet, f)

        log.debug('Sending SIGUSR1 to {}.'.format(e.pid))
        os.kill(e.pid, signal.SIGUSR1)
        os._exit(0)


def magnet_pprint(magnet):
    """ Pretty print magnet string.

    Parses title out of magnet string.
    """
    match = re.search('&dn=(.*?)&', magnet)
    if match:
        return match.group(1)
    else:
        return 'UNKNOWN TITLE'


def usr1_handler(signum, frame):
    """ Adds New Magnet File to Queue """
    log.debug('SIGUSR1 signal received.')
    with open(MAGNET_FILE, 'rb') as f:
        magnet = pickle.load(f)

    wait()
    torrent(magnet)


def wait():
    """ Blocks until first magnet is added to queue. """
    while magnet_queue.empty():
        time.sleep(0.5)


def term_handler(signum, frame):
    """ Remove All Magnet Files before Terminating """
    log.debug('Terminating signal received. Cleaning up magnets...')
    for i in range(1, magnet_counter.count + 1):
        remove_magnet(i)
    sys.exit(2)


@atexit.register
def exit_handler():
    """ Stop Transmission Daemon and Disconnect from VPN """
    sp.Popen(['killall', '-9', 'transmission-daemon'], stdout=sp.DEVNULL, stderr=sp.STDOUT)
    sp.Popen(['PIA', 'stop'], stdout=sp.DEVNULL, stderr=sp.STDOUT)


if __name__ == "__main__":
    delay_help = "delay starting the script for DELAY seconds"
    timeout_help = "time (in hours) to attempt to complete download before timing out"
    textme_help = "forward notifications via SMS messages (i.e. enable text notifications)"
    maxsize_help = 'max number of torrents allowed to download at one time (additional torrents '\
        'will be enqueued and start when a space opens up)'

    parser = gutils.ArgumentParser()
    parser.add_argument('magnet', help='The torrent magnet file.')
    parser.add_argument('-D', type=int, dest='delay', default=0, help=delay_help)
    parser.add_argument('-t', type=float, dest='timeout', default=8, help=timeout_help)
    parser.add_argument('-T', '--textme', dest='textme', action='store_true', help=textme_help)
    parser.add_argument('--maxsize', dest='maxsize', default=3, help=maxsize_help)
    args = parser.parse_args()

    signal.signal(signal.SIGUSR1, usr1_handler)
    signal.signal(signal.SIGTERM, term_handler)
    signal.signal(signal.SIGINT, term_handler)

    with gutils.logging.context(log, debug=args.debug), runtime_context():
        create_pidfile()

        time.sleep(args.delay)

        try:
            log.info('Connecting to VPN and starting transmission daemon...')
            sp.check_call(['PIA', 'start', 'nyc'], stdout=sp.DEVNULL)
            sp.check_call(['transmission-daemon'], stdout=sp.DEVNULL)
        except sp.CalledProcessError:
            raise RuntimeError('Failed to start the VPN and/or the transmission daemon.')
        else:
            magnet_queue.maxsize = args.maxsize
            torrent(args.magnet)

            wait()
            magnet_queue.join()
            notify('All torrents are complete.')
