#!/usr/bin/python3

"""Script to make torrenting movies and TV shows easier (uses transmission as a backend).

Connects to a VPN (using Private Internet Access), downloads the torrent (using a magnet file),
disconnects from the VPN when the download is finished, and then sends me a text message to let
me know the download is complete.

Multiple torrents can be downloaded at the same time by simply running this script multiple times
(using different magnet files). If another instance of this script is running, the primary instance
will be signaled to enqueue the new magnet file for download.
"""

import atexit
import argparse
import contextlib
import getpass
import os
import pickle
import threading
import time
import signal
import re
from pathlib import Path  # noqa: F401
import subprocess as sp
import sys
from typing import *
from types import *
import queue

import gutils

############################################################################################
#  gutils library: https://github.com/bbugyi200/pylibs/tree/master/gutils                  #
############################################################################################

# This lock blocks the torrents from self-destructing (removing themselves
# from the BitTorrent client) immediately after download. Instead, they
# seed until the very last torrent finishes downloading, at which point
# they all self-destruct at once.
kill_switch = threading.Lock()


class MagnetTracker:
    """Thread-Safe Counter of Magnet Files"""
    def __init__(self) -> None:
        self.lock = threading.Lock()

        self.ids: Dict[int, str] = {}
        self.next_key = 0
        self.active_torrents = 0

        kill_switch.acquire()

    def __getitem__(self, i: int) -> str:
        return self.ids[i]

    def done(self) -> int:
        with self.lock:
            self.active_torrents -= 1

            if self.active_torrents == 0:
                kill_switch.release()

            return self.active_torrents

    def new(self, id_list: List[str]) -> int:
        log.vdebug("id_list = %s", id_list)
        with self.lock:
            self.next_key += 1
            self.active_torrents += 1

            for ID in id_list:
                if ID in self.ids.values():
                    continue
                else:
                    self.ids[self.next_key] = ID
                    break
            else:
                raise RuntimeError(
                    'Something has gone wrong. '
                    'All Magnet IDs appear to have been used already.'
                )

            return self.next_key


log = gutils.logging.getEasyLogger(__name__)

xdg_data_dir = gutils.xdg.init('data')
ARGS_FILE = xdg_data_dir / 'args'
DELUGE = ['sudo', '-E', 'deluge-console']
# Created after the first torrent is successfully added to transmission.
MASTER_IS_ONLINE_FILE = xdg_data_dir / 'master_is_online'
SECONDS_IN_HOUR = 3600

mtracker = MagnetTracker()
mqueue: 'queue.Queue[str]' = queue.Queue()


def term_handler(signum: int, frame: FrameType) -> None:
    """Remove All Magnet Files before Terminating"""
    log.debug('Terminated via {} signal.'.format(signal.Signals(signum).name))
    purge_all()
    sys.exit(128 + signum)


def usr1_handler(signum: int, frame: FrameType) -> None:
    """Adds New Magnet File to Queue"""
    log.debug('SIGUSR1 signal received.')
    with ARGS_FILE.open('rb') as f:
        args = pickle.load(f)

    wait_for_first_magnet()
    torrent(args)


def exit_handler() -> None:
    """Stop Transmission Daemon and Disconnect from VPN"""
    sp.Popen(['sudo', 'killall', 'deluged'])
    sp.Popen(['sudo', 'killall', 'deluge-web'])
    sp.Popen(['PIA', 'stop'])

    if MASTER_IS_ONLINE_FILE.exists():
        MASTER_IS_ONLINE_FILE.unlink()


def main() -> None:
    atexit.register(exit_handler)

    signal.signal(signal.SIGTERM, term_handler)
    signal.signal(signal.SIGINT, term_handler)
    signal.signal(signal.SIGUSR1, usr1_handler)

    create_pidfile()
    time.sleep(args.delay)

    try:
        log.info('Connecting to VPN and starting transmission daemon...')
        sp.check_call(['PIA', 'start', args.vpn])
        sp.check_call(['sudo', 'chown', '-R', '{0}:{0}'.format(getpass.getuser()), args.download_dir])

        cmd_list = ['sudo', '-E', 'deluged']
        sp.check_call(cmd_list)

        cmd_list = ['sudo', '-E', 'deluge-web', '--fork']
        sp.check_call(cmd_list)

        purge_all()
    except sp.CalledProcessError:
        raise RuntimeError('Failed to start the VPN and/or the transmission daemon.')
    else:
        mqueue.maxsize = args.maxsize

        torrent(args)

        wait_for_first_magnet()
        mqueue.join()
        notify('All torrents are complete.')
    finally:
        sp.check_call(['sudo', 'chown', '-R', 'plex:plex', args.download_dir])


def torrent(args: argparse.Namespace) -> None:
    """Creates new torrent thread worker. """
    thread = threading.Thread(target=_torrent, args=(args,), daemon=True)
    thread.start()


def _torrent(args: argparse.Namespace) -> None:
    """Thread worker

    Downloads the torrent given by the @magnet string.
    """
    log.debug('Adding "{}" to Magnet Queue...'.format(magnet_pprint(args.magnet)))
    mqueue.put(args.magnet)

    download_started = False
    with gutils.logging.context(log, debug=args.debug, verbose=args.verbose), runtime_context():
        try:
            i = 0
            while True:
                time.sleep(1)
                try:
                    sp.check_call(DELUGE + ['add', '-p', args.download_dir, args.magnet])
                except sp.CalledProcessError:
                    i += 1
                    if i <= 10:
                        continue
                    else:
                        raise RuntimeError('Failed to start "{}".'.format(magnet_pprint(args.magnet)))
                else:
                    log.debug('Successfully added "{}".'.format(magnet_pprint(args.magnet)))

                    try:
                        id_list = [ID.split()[1] for ID in info('ID')]
                        mkey = mtracker.new(id_list)
                    except ValueError:
                        raise RuntimeError(
                            'Something is not right. The torrent has been added '
                            'to the P2P client but `info(ID)` has somehow failed.'
                        )

                    if not MASTER_IS_ONLINE_FILE.exists():
                        MASTER_IS_ONLINE_FILE.touch()

                    break

            i = 0
            while True:
                SLEEP_TIME = 5

                i += 1
                if args.timeout:
                    if i > (args.timeout * SECONDS_IN_HOUR / SLEEP_TIME):
                        msg = "Torrent is still attempting to download \"{0}\" after {1:.1f} hour(s) "\
                              " elapsed time. Shutting down early.".format(magnet_pprint(args.magnet), args.timeout)
                        raise RuntimeError(msg)

                time.sleep(SLEEP_TIME)

                full_state = info('State', ID=mtracker[mkey])

                state = str(full_state).split()[1]
                if state == 'Downloading':
                    download_started = True
                elif state == 'Seeding' or (state == 'Queued' and download_started):
                    break

            gutils.notify('Finished Downloading "{}".'.format(magnet_pprint(args.magnet)))

        finally:
            mtracker.done()

            with kill_switch:
                rm(mtracker[mkey])
                mqueue.get()
                mqueue.task_done()


@contextlib.contextmanager
def runtime_context() -> Generator:
    """RuntimeError Context Manager

    Context manager that makes sure users are notified of runtime exceptions.
    """
    try:
        yield
    except RuntimeError as e:
        notify(str(e))
        raise


def notify(msg: str) -> None:
    """Sends Desktop Notification and (possibly) SMS Notification"""
    log.debug('Sending notification to user.'.format(msg))
    gutils.notify('-t', '0', msg)
    if args.textme:
        sp.check_call(['textme', msg])


def purge_all() -> None:
    try:
        full_id_list = info('ID')
        log.vdebug("full_id_list = %s", full_id_list)
    except ValueError:
        return

    all_ids = [ID.split()[1] for ID in full_id_list]
    for ID in all_ids:
        rm(ID)


def rm(ID: str) -> None:
    """Removes Transmission Magnet File"""
    try:
        sp.check_call(DELUGE + ['rm', ID])
        log.debug('Successfully removed magnet #{}.'.format(ID))
    except sp.CalledProcessError:
        log.debug('Attempted to remove magnet #{} but it is NOT active.'.format(ID))


def create_pidfile() -> None:
    """Duplicate Process Management"""
    try:
        gutils.create_pidfile()
    except gutils.StillAliveException as e:
        if not MASTER_IS_ONLINE_FILE.exists():
            while not MASTER_IS_ONLINE_FILE.exists():
                log.debug('{} does not exist yet. Waiting...'.format(MASTER_IS_ONLINE_FILE))
                time.sleep(1)

            time.sleep(1)

        with ARGS_FILE.open('wb') as f:
            pickle.dump(args, f)

        log.debug('Sending SIGUSR1 to {}.'.format(e.pid))
        os.kill(e.pid, signal.SIGUSR1)

        # Exit without invoking exit handler.
        os._exit(0)


def magnet_pprint(magnet: str) -> str:
    """Pretty print magnet string.

    Parses title out of magnet string.
    """
    match = re.search('&dn=(.*?)&', magnet)
    if match:
        return match.group(1)
    else:
        return 'UNKNOWN TITLE'


def info(field: str, ID: str = None) -> Union[str, List[str]]:
    log.vdebug("ID = %s", ID)

    cmd = (
        "{DELUGE} info --sort-reverse=time_added {ID} | "
        "awk -F: '{{if($1==\"{field}\")print $0}}'".format(
            DELUGE=' '.join(DELUGE),
            field=field,
            ID=('' if ID is None else ID)
        )
    )
    out = gutils.shell(cmd)
    ret = out.split('\n')

    if ret[0] == '':
        raise ValueError(
            'Something went wrong with the `info` function. '
            'Local state:\n\n{}'.format(locals())
        )

    return ret if ID is None else ret[0]


def wait_for_first_magnet() -> None:
    """Blocks until first magnet is added to queue."""
    while mqueue.empty():
        time.sleep(0.5)


if __name__ == "__main__":
    parser = gutils.ArgumentParser()
    parser.add_argument('magnet', help='The torrent magnet file.')

    default = '/media/bryan/hercules/media/Entertainment/Movies'
    parser.add_argument('-w', type=Path, dest='download_dir', default=default,
                        help='The directory that the torrents will be downloaded to. Defaults to {}.'.format(default))

    default = 0
    parser.add_argument('-D', type=int, dest='delay', default=default,
                        help='Delay starting the script for DELAY seconds. Defaults to {}.'.format(default))

    default = 0
    parser.add_argument('-t', type=float, dest='timeout', default=default,
                        help='Time (in hours) to attempt to complete download before timing out. If set to 0, this script will run forever without ever timing out. Defaults to {}.'.format(default))

    parser.add_argument('-T', '--textme', dest='textme', action='store_true',
                        help='Forward notifications via SMS messages (i.e. enable text notifications).')

    default = 0
    parser.add_argument('--maxsize', type=int, dest='maxsize', default=default,
                        help='Max number of torrents allowed to download at one time (additional torrents will be enqueued and start when a space opens up). Defaults to {}.'.format(default))

    default = 'nyc'
    parser.add_argument('--vpn', type=str, dest='vpn', nargs='?', default=default,
                        help='VPN to connect to. Defaults to {}.'.format(default))

    args = parser.parse_args()


    main()
